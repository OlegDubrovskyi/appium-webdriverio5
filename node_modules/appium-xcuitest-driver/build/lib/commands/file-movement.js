"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAvailableBundleIds = getAvailableBundleIds;
exports.parseContainerPath = parseContainerPath;
exports.default = exports.commands = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _appiumSupport = require("appium-support");

var _path = _interopRequireDefault(require("path"));

var _appiumIosDriver = require("appium-ios-driver");

var _logger = _interopRequireDefault(require("../logger"));

var _teen_process = require("teen_process");

var _nodeSimctl = require("node-simctl");

var _asyncbox = require("asyncbox");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _appiumIosDevice = require("appium-ios-device");

const CONTAINER_PATH_MARKER = '@';
const CONTAINER_PATH_PATTERN = new RegExp(`^${CONTAINER_PATH_MARKER}([^/]+)/(.*)`);
const CONTAINER_TYPE_SEPARATOR = ':';
const IFUSE_CONTAINER_DOCUMENTS = 'documents';
const CONTAINER_DOCUMENTS_PATH = 'Documents';
let commands = _appiumIosDriver.iosCommands.file;
exports.commands = commands;

async function verifyIFusePresence() {
  if (!(await _appiumSupport.fs.which('ifuse'))) {
    _logger.default.errorAndThrow(`'ifuse' tool is required to be installed on the machine. ` + `Install it using 'brew cask install osxfuse && brew install ifuse' or check ` + `if it is available in PATH environment variable if the tool is already installed. ` + `Current PATH value: ${process.env.PATH}`);
  }
}

async function mountDevice(device, iFuseArgs) {
  _logger.default.debug(`Starting ifuse with args '${iFuseArgs}'...`);

  try {
    await (0, _teen_process.exec)('ifuse', iFuseArgs);
  } catch (e) {
    const bundleIds = await getAvailableBundleIds(device.udid);

    _logger.default.errorAndThrow(`Cannot mount the media folder of the device with UDID ${device.udid}. ` + `Make sure osxfuse plugin has necessary permissions in System Preferences->Security & Privacy. ` + `${bundleIds} might be able to mount as '@bundleId:documents/'. ` + `Error code: ${e.code}; stderr output: ${e.stderr}`);
  }
}

function verifyIsSubPath(originalPath, root) {
  const normalizedRoot = _path.default.normalize(root);

  const normalizedPath = _path.default.normalize(_path.default.dirname(originalPath));

  if (normalizedRoot !== originalPath && !normalizedPath.startsWith(normalizedRoot)) {
    _logger.default.errorAndThrow(`'${normalizedPath}' is expected to be a subpath of '${normalizedRoot}'`);
  }
}

async function createAfcClient(udid, bundleId, containerType) {
  if (!bundleId) {
    return await _appiumIosDevice.services.startAfcService(udid);
  }

  const service = await _appiumIosDevice.services.startHouseArrestService(udid);

  if (isDocuments(containerType)) {
    return await service.vendDocuments(bundleId);
  } else {
    return await service.vendContainer(bundleId);
  }
}

function isDocuments(containerType) {
  return _lodash.default.toLower(containerType) === IFUSE_CONTAINER_DOCUMENTS;
}

async function mkdirpDevice(service, dir) {
  if (dir === '.' || dir === '/') {
    return;
  }

  try {
    await service.listDirectory(dir);
    return;
  } catch (e) {
    await mkdirpDevice(service, _path.default.dirname(dir));
  }

  await service.createDirectory(dir);
}

async function createService(udid, remotePath) {
  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer,
      containerType
    } = await parseContainerPath(remotePath);
    const service = await createAfcClient(udid, bundleId, containerType);
    const relativePath = isDocuments(containerType) ? _path.default.join(CONTAINER_DOCUMENTS_PATH, pathInContainer) : pathInContainer;
    return {
      service,
      relativePath
    };
  } else {
    const service = await createAfcClient(udid);
    const relativePath = remotePath;
    return {
      service,
      relativePath
    };
  }
}

async function parseContainerPath(remotePath, containerRootSupplier) {
  const match = CONTAINER_PATH_PATTERN.exec(remotePath);

  if (!match) {
    _logger.default.errorAndThrow(`It is expected that package identifier ` + `starts with '${CONTAINER_PATH_MARKER}' and is separated from the ` + `relative path with a single slash. '${remotePath}' is given instead`);
  }

  let [, bundleId, relativePath] = match;
  let containerType = null;
  const typeSeparatorPos = bundleId.indexOf(CONTAINER_TYPE_SEPARATOR);

  if (typeSeparatorPos > 0 && typeSeparatorPos < bundleId.length - 1) {
    containerType = bundleId.substring(typeSeparatorPos + 1);

    _logger.default.debug(`Parsed container type: ${containerType}`);

    bundleId = bundleId.substring(0, typeSeparatorPos);
  }

  if (_lodash.default.isNil(containerRootSupplier)) {
    const pathInContainer = relativePath;
    return {
      bundleId,
      pathInContainer,
      containerType
    };
  }

  const containerRoot = _lodash.default.isFunction(containerRootSupplier) ? await containerRootSupplier(bundleId, containerType) : containerRootSupplier;

  const pathInContainer = _path.default.posix.resolve(containerRoot, relativePath);

  verifyIsSubPath(pathInContainer, containerRoot);
  return {
    bundleId,
    pathInContainer,
    containerType
  };
}

async function pushFileToSimulator(device, remotePath, base64Data) {
  const buffer = Buffer.from(base64Data, 'base64');

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await (0, _nodeSimctl.getAppContainer)(device.udid, appBundle, null, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will put the data into '${dstPath}'`);

    if (!(await _appiumSupport.fs.exists(_path.default.dirname(dstPath)))) {
      _logger.default.debug(`The destination folder '${_path.default.dirname(dstPath)}' does not exist. Creating...`);

      await (0, _appiumSupport.mkdirp)(_path.default.dirname(dstPath));
    }

    await _appiumSupport.fs.writeFile(dstPath, buffer);
    return;
  }

  const dstFolder = await _appiumSupport.tempDir.openDir();

  const dstPath = _path.default.resolve(dstFolder, _path.default.basename(remotePath));

  try {
    await _appiumSupport.fs.writeFile(dstPath, buffer);
    await (0, _nodeSimctl.addMedia)(device.udid, dstPath);
  } finally {
    await _appiumSupport.fs.rimraf(dstFolder);
  }
}

async function pushFileToRealDevice(device, remotePath, base64Data) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    await mkdirpDevice(service, _path.default.dirname(relativePath));
    const stream = await service.createWriteStream(relativePath, {
      autoClose: true
    });
    stream.write(Buffer.from(base64Data, 'base64'));
    const closeEvent = new _bluebird.default(resolve => stream.on('close', resolve));
    stream.destroy();
    await closeEvent;
  } finally {
    service.close();
  }
}

async function pullFromSimulator(device, remotePath, isFile) {
  let pathOnServer;

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await (0, _nodeSimctl.getAppContainer)(device.udid, appBundle, null, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will get the data from '${dstPath}'`);

    pathOnServer = dstPath;
  } else {
    const simRoot = device.getDir();
    pathOnServer = _path.default.posix.join(simRoot, remotePath);
    verifyIsSubPath(pathOnServer, simRoot);

    _logger.default.info(`Got the full item path: ${pathOnServer}`);
  }

  if (!(await _appiumSupport.fs.exists(pathOnServer))) {
    _logger.default.errorAndThrow(`The remote ${isFile ? 'file' : 'folder'} at '${pathOnServer}' does not exist`);
  }

  const buffer = isFile ? await _appiumSupport.fs.readFile(pathOnServer) : await _appiumSupport.zip.toInMemoryZip(pathOnServer);
  return Buffer.from(buffer).toString('base64');
}

async function pullFromRealDevice(device, remotePath, isFile) {
  await verifyIFusePresence();
  const mntRoot = await _appiumSupport.tempDir.openDir();
  let isUnmountSuccessful = true;

  try {
    let dstPath = _path.default.resolve(mntRoot, remotePath);

    let ifuseArgs = ['-u', device.udid, mntRoot];

    if (CONTAINER_PATH_PATTERN.test(remotePath)) {
      const {
        bundleId,
        pathInContainer,
        containerType
      } = await parseContainerPath(remotePath, mntRoot);
      dstPath = pathInContainer;

      _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will get the data from '${dstPath}'`);

      ifuseArgs = ['-u', device.udid, isDocuments(containerType) ? '--documents' : '--container', bundleId, mntRoot];
    } else {
      verifyIsSubPath(dstPath, mntRoot);
    }

    await mountDevice(device, ifuseArgs);
    isUnmountSuccessful = false;

    try {
      if (!(await _appiumSupport.fs.exists(dstPath))) {
        _logger.default.errorAndThrow(`The remote ${isFile ? 'file' : 'folder'} at '${dstPath}' does not exist`);
      }

      const buffer = isFile ? await _appiumSupport.fs.readFile(dstPath) : await _appiumSupport.zip.toInMemoryZip(dstPath);
      return Buffer.from(buffer).toString('base64');
    } finally {
      (0, _asyncbox.retry)(2, async function () {
        await (0, _teen_process.exec)('umount', [mntRoot]);
      });
      isUnmountSuccessful = true;
    }
  } finally {
    if (isUnmountSuccessful) {
      await _appiumSupport.fs.rimraf(mntRoot);
    } else {
      _logger.default.warn(`Umount has failed, so not removing '${mntRoot}'`);
    }
  }
}

async function getAvailableBundleIds(udid) {
  const service = await _appiumIosDevice.services.startInstallationProxyService(udid);

  try {
    const applications = await service.listApplications({
      applicationType: 'User'
    });
    const bundleIds = [];

    for (const [key, value] of Object.entries(applications)) {
      if (!value.UIFileSharingEnabled) {
        continue;
      }

      bundleIds.push(key);
    }

    return bundleIds;
  } finally {
    service.close();
  }
}

commands.pushFile = async function pushFile(remotePath, base64Data) {
  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  if (_lodash.default.isArray(base64Data)) {
    base64Data = Buffer.from(base64Data).toString('utf8');
  }

  return this.isSimulator() ? await pushFileToSimulator(this.opts.device, remotePath, base64Data) : await pushFileToRealDevice(this.opts.device, remotePath, base64Data);
};

commands.pullFile = async function pullFile(remotePath) {
  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  return this.isSimulator() ? await pullFromSimulator(this.opts.device, remotePath, true) : await pullFromRealDevice(this.opts.device, remotePath, true);
};

commands.getSimFileFullPath = async function getSimFileFullPath(remotePath) {
  let basePath = this.opts.device.getDir();
  let appName = null;

  if (this.opts.app) {
    let appNameRegex = new RegExp(`\\${_path.default.sep}([\\w-]+\\.app)`);
    let appNameMatches = appNameRegex.exec(this.opts.app);

    if (appNameMatches) {
      appName = appNameMatches[1];
    }
  }

  if (_appiumSupport.system.isWindows()) {
    if (remotePath.indexof('://') === 1) {
      remotePath = remotePath.slice(4);
    }
  } else {
    if (remotePath.indexOf('/') === 0) {
      remotePath = remotePath.slice(1);
    }
  }

  if (remotePath.startsWith(appName)) {
    let findPath = basePath;

    if (!this.opts.platformVersion || _appiumSupport.util.compareVersions(this.opts.platformVersion, '>=', '8.0')) {
      findPath = _path.default.resolve(basePath, 'Containers', 'Bundle');
    }

    findPath = findPath.replace(/\s/g, '\\ ');
    let {
      stdout
    } = await (0, _teen_process.exec)('find', [findPath, '-name', appName]);
    let appRoot = stdout.replace(/\n$/, '');
    let subPath = remotePath.substring(appName.length + 1);

    let fullPath = _path.default.resolve(appRoot, subPath);

    _logger.default.debug(`Finding app-relative file: '${fullPath}'`);

    return fullPath;
  }

  let fullPath = _path.default.resolve(basePath, remotePath);

  _logger.default.debug(`Finding sim-relative file: ${fullPath}`);

  return fullPath;
};

commands.pullFolder = async function pullFolder(remotePath) {
  if (!remotePath.endsWith('/')) {
    remotePath = `${remotePath}/`;
  }

  return this.isSimulator() ? await pullFromSimulator(this.opts.device, remotePath, false) : await pullFromRealDevice(this.opts.device, remotePath, false);
};

var _default = commands;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9maWxlLW1vdmVtZW50LmpzIl0sIm5hbWVzIjpbIkNPTlRBSU5FUl9QQVRIX01BUktFUiIsIkNPTlRBSU5FUl9QQVRIX1BBVFRFUk4iLCJSZWdFeHAiLCJDT05UQUlORVJfVFlQRV9TRVBBUkFUT1IiLCJJRlVTRV9DT05UQUlORVJfRE9DVU1FTlRTIiwiQ09OVEFJTkVSX0RPQ1VNRU5UU19QQVRIIiwiY29tbWFuZHMiLCJpb3NDb21tYW5kcyIsImZpbGUiLCJ2ZXJpZnlJRnVzZVByZXNlbmNlIiwiZnMiLCJ3aGljaCIsImxvZyIsImVycm9yQW5kVGhyb3ciLCJwcm9jZXNzIiwiZW52IiwiUEFUSCIsIm1vdW50RGV2aWNlIiwiZGV2aWNlIiwiaUZ1c2VBcmdzIiwiZGVidWciLCJlIiwiYnVuZGxlSWRzIiwiZ2V0QXZhaWxhYmxlQnVuZGxlSWRzIiwidWRpZCIsImNvZGUiLCJzdGRlcnIiLCJ2ZXJpZnlJc1N1YlBhdGgiLCJvcmlnaW5hbFBhdGgiLCJyb290Iiwibm9ybWFsaXplZFJvb3QiLCJwYXRoIiwibm9ybWFsaXplIiwibm9ybWFsaXplZFBhdGgiLCJkaXJuYW1lIiwic3RhcnRzV2l0aCIsImNyZWF0ZUFmY0NsaWVudCIsImJ1bmRsZUlkIiwiY29udGFpbmVyVHlwZSIsInNlcnZpY2VzIiwic3RhcnRBZmNTZXJ2aWNlIiwic2VydmljZSIsInN0YXJ0SG91c2VBcnJlc3RTZXJ2aWNlIiwiaXNEb2N1bWVudHMiLCJ2ZW5kRG9jdW1lbnRzIiwidmVuZENvbnRhaW5lciIsIl8iLCJ0b0xvd2VyIiwibWtkaXJwRGV2aWNlIiwiZGlyIiwibGlzdERpcmVjdG9yeSIsImNyZWF0ZURpcmVjdG9yeSIsImNyZWF0ZVNlcnZpY2UiLCJyZW1vdGVQYXRoIiwidGVzdCIsInBhdGhJbkNvbnRhaW5lciIsInBhcnNlQ29udGFpbmVyUGF0aCIsInJlbGF0aXZlUGF0aCIsImpvaW4iLCJjb250YWluZXJSb290U3VwcGxpZXIiLCJtYXRjaCIsImV4ZWMiLCJ0eXBlU2VwYXJhdG9yUG9zIiwiaW5kZXhPZiIsImxlbmd0aCIsInN1YnN0cmluZyIsImlzTmlsIiwiY29udGFpbmVyUm9vdCIsImlzRnVuY3Rpb24iLCJwb3NpeCIsInJlc29sdmUiLCJwdXNoRmlsZVRvU2ltdWxhdG9yIiwiYmFzZTY0RGF0YSIsImJ1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJkc3RQYXRoIiwiYXBwQnVuZGxlIiwiaW5mbyIsImV4aXN0cyIsIndyaXRlRmlsZSIsImRzdEZvbGRlciIsInRlbXBEaXIiLCJvcGVuRGlyIiwiYmFzZW5hbWUiLCJyaW1yYWYiLCJwdXNoRmlsZVRvUmVhbERldmljZSIsInN0cmVhbSIsImNyZWF0ZVdyaXRlU3RyZWFtIiwiYXV0b0Nsb3NlIiwid3JpdGUiLCJjbG9zZUV2ZW50IiwiQiIsIm9uIiwiZGVzdHJveSIsImNsb3NlIiwicHVsbEZyb21TaW11bGF0b3IiLCJpc0ZpbGUiLCJwYXRoT25TZXJ2ZXIiLCJzaW1Sb290IiwiZ2V0RGlyIiwicmVhZEZpbGUiLCJ6aXAiLCJ0b0luTWVtb3J5WmlwIiwidG9TdHJpbmciLCJwdWxsRnJvbVJlYWxEZXZpY2UiLCJtbnRSb290IiwiaXNVbm1vdW50U3VjY2Vzc2Z1bCIsImlmdXNlQXJncyIsIndhcm4iLCJzdGFydEluc3RhbGxhdGlvblByb3h5U2VydmljZSIsImFwcGxpY2F0aW9ucyIsImxpc3RBcHBsaWNhdGlvbnMiLCJhcHBsaWNhdGlvblR5cGUiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJVSUZpbGVTaGFyaW5nRW5hYmxlZCIsInB1c2giLCJwdXNoRmlsZSIsImVuZHNXaXRoIiwiaXNBcnJheSIsImlzU2ltdWxhdG9yIiwib3B0cyIsInB1bGxGaWxlIiwiZ2V0U2ltRmlsZUZ1bGxQYXRoIiwiYmFzZVBhdGgiLCJhcHBOYW1lIiwiYXBwIiwiYXBwTmFtZVJlZ2V4Iiwic2VwIiwiYXBwTmFtZU1hdGNoZXMiLCJzeXN0ZW0iLCJpc1dpbmRvd3MiLCJpbmRleG9mIiwic2xpY2UiLCJmaW5kUGF0aCIsInBsYXRmb3JtVmVyc2lvbiIsInV0aWwiLCJjb21wYXJlVmVyc2lvbnMiLCJyZXBsYWNlIiwic3Rkb3V0IiwiYXBwUm9vdCIsInN1YlBhdGgiLCJmdWxsUGF0aCIsInB1bGxGb2xkZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxNQUFNQSxxQkFBcUIsR0FBRyxHQUE5QjtBQUVBLE1BQU1DLHNCQUFzQixHQUFHLElBQUlDLE1BQUosQ0FBWSxJQUFHRixxQkFBc0IsY0FBckMsQ0FBL0I7QUFDQSxNQUFNRyx3QkFBd0IsR0FBRyxHQUFqQztBQUNBLE1BQU1DLHlCQUF5QixHQUFHLFdBQWxDO0FBQ0EsTUFBTUMsd0JBQXdCLEdBQUcsV0FBakM7QUFHQSxJQUFJQyxRQUFRLEdBQUdDLDZCQUFZQyxJQUEzQjs7O0FBRUEsZUFBZUMsbUJBQWYsR0FBc0M7QUFDcEMsTUFBSSxFQUFDLE1BQU1DLGtCQUFHQyxLQUFILENBQVMsT0FBVCxDQUFQLENBQUosRUFBOEI7QUFDNUJDLG9CQUFJQyxhQUFKLENBQW1CLDJEQUFELEdBQ0MsOEVBREQsR0FFQyxvRkFGRCxHQUdDLHVCQUFzQkMsT0FBTyxDQUFDQyxHQUFSLENBQVlDLElBQUssRUFIMUQ7QUFJRDtBQUNGOztBQUVELGVBQWVDLFdBQWYsQ0FBNEJDLE1BQTVCLEVBQW9DQyxTQUFwQyxFQUErQztBQUM3Q1Asa0JBQUlRLEtBQUosQ0FBVyw2QkFBNEJELFNBQVUsTUFBakQ7O0FBQ0EsTUFBSTtBQUNGLFVBQU0sd0JBQUssT0FBTCxFQUFjQSxTQUFkLENBQU47QUFDRCxHQUZELENBRUUsT0FBT0UsQ0FBUCxFQUFVO0FBQ1YsVUFBTUMsU0FBUyxHQUFHLE1BQU1DLHFCQUFxQixDQUFDTCxNQUFNLENBQUNNLElBQVIsQ0FBN0M7O0FBQ0FaLG9CQUFJQyxhQUFKLENBQW1CLHlEQUF3REssTUFBTSxDQUFDTSxJQUFLLElBQXJFLEdBQ0Ms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LE1BQVIsR0FBaUIsQ0FBdEMsQ0FBZDs7QUFDQSxRQUFJaUYsUUFBUSxHQUFHbEgsY0FBS3VDLE9BQUwsQ0FBYXlFLE9BQWIsRUFBc0JDLE9BQXRCLENBQWY7O0FBQ0FwSSxvQkFBSVEsS0FBSixDQUFXLCtCQUE4QjZILFFBQVMsR0FBbEQ7O0FBQ0EsV0FBT0EsUUFBUDtBQUNEOztBQUVELE1BQUlBLFFBQVEsR0FBR2xILGNBQUt1QyxPQUFMLENBQWF5RCxRQUFiLEVBQXVCMUUsVUFBdkIsQ0FBZjs7QUFDQXpDLGtCQUFJUSxLQUFKLENBQVcsOEJBQTZCNkgsUUFBUyxFQUFqRDs7QUFDQSxTQUFPQSxRQUFQO0FBQ0QsQ0F6Q0Q7O0FBMkNBM0ksUUFBUSxDQUFDNEksVUFBVCxHQUFzQixlQUFlQSxVQUFmLENBQTJCN0YsVUFBM0IsRUFBdUM7QUFDM0QsTUFBSSxDQUFDQSxVQUFVLENBQUNvRSxRQUFYLENBQW9CLEdBQXBCLENBQUwsRUFBK0I7QUFDN0JwRSxJQUFBQSxVQUFVLEdBQUksR0FBRUEsVUFBVyxHQUEzQjtBQUNEOztBQUNELFNBQU8sS0FBS3NFLFdBQUwsS0FDSCxNQUFNM0IsaUJBQWlCLENBQUMsS0FBSzRCLElBQUwsQ0FBVTFHLE1BQVgsRUFBbUJtQyxVQUFuQixFQUErQixLQUEvQixDQURwQixHQUVILE1BQU1vRCxrQkFBa0IsQ0FBQyxLQUFLbUIsSUFBTCxDQUFVMUcsTUFBWCxFQUFtQm1DLFVBQW5CLEVBQStCLEtBQS9CLENBRjVCO0FBR0QsQ0FQRDs7ZUFXZS9DLFEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgc3lzdGVtLCBmcywgdGVtcERpciwgbWtkaXJwLCB6aXAsIHV0aWwgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGlvc0NvbW1hbmRzIH0gZnJvbSAnYXBwaXVtLWlvcy1kcml2ZXInO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyBhZGRNZWRpYSwgZ2V0QXBwQ29udGFpbmVyIH0gZnJvbSAnbm9kZS1zaW1jdGwnO1xuaW1wb3J0IHsgcmV0cnkgfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBzZXJ2aWNlcyB9IGZyb20gJ2FwcGl1bS1pb3MtZGV2aWNlJztcblxuY29uc3QgQ09OVEFJTkVSX1BBVEhfTUFSS0VSID0gJ0AnO1xuLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20vci9QTGRCMEcvMlxuY29uc3QgQ09OVEFJTkVSX1BBVEhfUEFUVEVSTiA9IG5ldyBSZWdFeHAoYF4ke0NPTlRBSU5FUl9QQVRIX01BUktFUn0oW14vXSspLyguKilgKTtcbmNvbnN0IENPTlRBSU5FUl9UWVBFX1NFUEFSQVRPUiA9ICc6JztcbmNvbnN0IElGVVNFX0NPTlRBSU5FUl9ET0NVTUVOVFMgPSAnZG9jdW1lbnRzJztcbmNvbnN0IENPTlRBSU5FUl9ET0NVTUVOVFNfUEFUSCA9ICdEb2N1bWVudHMnO1xuXG5cbmxldCBjb21tYW5kcyA9IGlvc0NvbW1hbmRzLmZpbGU7XG5cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeUlGdXNlUHJlc2VuY2UgKCkge1xuICBpZiAoIWF3YWl0IGZzLndoaWNoKCdpZnVzZScpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYCdpZnVzZScgdG9vbCBpcyByZXF1aXJlZCB0byBiZSBpbnN0YWxsZWQgb24gdGhlIG1hY2hpbmUuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBJbnN0YWxsIGl0IHVzaW5nICdicmV3IGNhc2sgaW5zdGFsbCBvc3hmdXNlICYmIGJyZXcgaW5zdGFsbCBpZnVzZScgb3IgY2hlY2sgYCArXG4gICAgICAgICAgICAgICAgICAgICAgYGlmIGl0IGlzIGF2YWlsYWJsZSBpbiBQQVRIIGVudmlyb25tZW50IHZhcmlhYmxlIGlmIHRoZSB0b29sIGlzIGFscmVhZHkgaW5zdGFsbGVkLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgQ3VycmVudCBQQVRIIHZhbHVlOiAke3Byb2Nlc3MuZW52LlBBVEh9YCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gbW91bnREZXZpY2UgKGRldmljZSwgaUZ1c2VBcmdzKSB7XG4gIGxvZy5kZWJ1ZyhgU3RhcnRpbmcgaWZ1c2Ugd2l0aCBhcmdzICcke2lGdXNlQXJnc30nLi4uYCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYygnaWZ1c2UnLCBpRnVzZUFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc3QgYnVuZGxlSWRzID0gYXdhaXQgZ2V0QXZhaWxhYmxlQnVuZGxlSWRzKGRldmljZS51ZGlkKTtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgQ2Fubm90IG1vdW50IHRoZSBtZWRpYSBmb2xkZXIgb2YgdGhlIGRldmljZSB3aXRoIFVESUQgJHtkZXZpY2UudWRpZH0uIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBNYWtlIHN1cmUgb3N4ZnVzZSBwbHVnaW4gaGFzIG5lY2Vzc2FyeSBwZXJtaXNzaW9ucyBpbiBTeXN0ZW0gUHJlZmVyZW5jZXMtPlNlY3VyaXR5ICYgUHJpdmFjeS4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYCR7YnVuZGxlSWRzfSBtaWdodCBiZSBhYmxlIHRvIG1vdW50IGFzICdAYnVuZGxlSWQ6ZG9jdW1lbnRzLycuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBFcnJvciBjb2RlOiAke2UuY29kZX07IHN0ZGVyciBvdXRwdXQ6ICR7ZS5zdGRlcnJ9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmVyaWZ5SXNTdWJQYXRoIChvcmlnaW5hbFBhdGgsIHJvb3QpIHtcbiAgY29uc3Qgbm9ybWFsaXplZFJvb3QgPSBwYXRoLm5vcm1hbGl6ZShyb290KTtcbiAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBwYXRoLm5vcm1hbGl6ZShwYXRoLmRpcm5hbWUob3JpZ2luYWxQYXRoKSk7XG4gIC8vIElmIG9yaWdpbmFsUGF0aCBpcyByb290LCBgL2AsIG9yaWdpbmFsUGF0aCBzaG91bGQgZXF1YWwgdG8gbm9ybWFsaXplZFJvb3RcbiAgaWYgKG5vcm1hbGl6ZWRSb290ICE9PSBvcmlnaW5hbFBhdGggJiYgIW5vcm1hbGl6ZWRQYXRoLnN0YXJ0c1dpdGgobm9ybWFsaXplZFJvb3QpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYCcke25vcm1hbGl6ZWRQYXRofScgaXMgZXhwZWN0ZWQgdG8gYmUgYSBzdWJwYXRoIG9mICcke25vcm1hbGl6ZWRSb290fSdgKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVBZmNDbGllbnQgKHVkaWQsIGJ1bmRsZUlkLCBjb250YWluZXJUeXBlKSB7XG4gIGlmICghYnVuZGxlSWQpIHtcbiAgICByZXR1cm4gYXdhaXQgc2VydmljZXMuc3RhcnRBZmNTZXJ2aWNlKHVkaWQpO1xuICB9XG4gIGNvbnN0IHNlcnZpY2UgPSBhd2FpdCBzZXJ2aWNlcy5zdGFydEhvdXNlQXJyZXN0U2VydmljZSh1ZGlkKTtcbiAgaWYgKGlzRG9jdW1lbnRzKGNvbnRhaW5lclR5cGUpKSB7XG4gICAgcmV0dXJuIGF3YWl0IHNlcnZpY2UudmVuZERvY3VtZW50cyhidW5kbGVJZCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF3YWl0IHNlcnZpY2UudmVuZENvbnRhaW5lcihidW5kbGVJZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNEb2N1bWVudHMgKGNvbnRhaW5lclR5cGUpIHtcbiAgcmV0dXJuIF8udG9Mb3dlcihjb250YWluZXJUeXBlKSA9PT0gSUZVU0VfQ09OVEFJTkVSX0RPQ1VNRU5UUztcbn1cblxuYXN5bmMgZnVuY3Rpb24gbWtkaXJwRGV2aWNlIChzZXJ2aWNlLCBkaXIpIHtcbiAgaWYgKGRpciA9PT0gJy4nIHx8IGRpciA9PT0gJy8nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgc2VydmljZS5saXN0RGlyZWN0b3J5KGRpcik7XG4gICAgcmV0dXJuO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVGhpcyBtZWFucyB0aGF0IHRoZSBkaXJlY3RvcnkgaXMgbWlzc2luZyBhbmQgd2UgZ290IGFuIG9iamVjdCBub3QgZm91bmQgZXJyb3IuIFRoZXJlZm9yZSwgd2UgYXJlIGdvaW5nIHRvIHRoZSBwYXJlbnRcbiAgICBhd2FpdCBta2RpcnBEZXZpY2Uoc2VydmljZSwgcGF0aC5kaXJuYW1lKGRpcikpO1xuICB9XG4gIGF3YWl0IHNlcnZpY2UuY3JlYXRlRGlyZWN0b3J5KGRpcik7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNlcnZpY2UgKHVkaWQsIHJlbW90ZVBhdGgpIHtcbiAgaWYgKENPTlRBSU5FUl9QQVRIX1BBVFRFUk4udGVzdChyZW1vdGVQYXRoKSkge1xuICAgIGNvbnN0IHsgYnVuZGxlSWQsIHBhdGhJbkNvbnRhaW5lciwgY29udGFpbmVyVHlwZSB9ID0gYXdhaXQgcGFyc2VDb250YWluZXJQYXRoKHJlbW90ZVBhdGgpO1xuICAgIGNvbnN0IHNlcnZpY2UgPSBhd2FpdCBjcmVhdGVBZmNDbGllbnQodWRpZCwgYnVuZGxlSWQsIGNvbnRhaW5lclR5cGUpO1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IGlzRG9jdW1lbnRzKGNvbnRhaW5lclR5cGUpID8gcGF0aC5qb2luKENPTlRBSU5FUl9ET0NVTUVOVFNfUEFUSCwgcGF0aEluQ29udGFpbmVyKSA6IHBhdGhJbkNvbnRhaW5lcjtcbiAgICByZXR1cm4ge3NlcnZpY2UsIHJlbGF0aXZlUGF0aH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2VydmljZSA9IGF3YWl0IGNyZWF0ZUFmY0NsaWVudCh1ZGlkKTtcbiAgICBjb25zdCByZWxhdGl2ZVBhdGggPSByZW1vdGVQYXRoO1xuICAgIHJldHVybiB7c2VydmljZSwgcmVsYXRpdmVQYXRofTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbnRhaW5lck9iamVjdFxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBidW5kbGVJZCAtIFRoZSBwYXJzZWQgYnVuZGxlIGlkZW50aWZpZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXRoSW5Db250YWluZXIgLSBUaGUgYWJzb2x1dGUgZnVsbCBwYXRoIG9mIHRoZSBpdGVtIG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbVxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBjb250YWluZXJUeXBlIC0gVGhlIGNvbnRhaW5lciB0eXBlXG4gKi9cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGFjdHVhbCBwYXRoIGFuZCB0aGUgYnVuZGxlIGlkZW50aWZpZXIgZnJvbSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSBnaXZlbiBwYXRoIHN0cmluZy4gVGhlIHN0cmluZyBzaG91bGRcbiAqIG1hdGNoIGBDT05UQUlORVJfUEFUSF9QQVRURVJOYCByZWdleHAsIG90aGVyd2lzZSBhbiBlcnJvciBpcyBnb2luZ1xuICogdG8gYmUgdGhyb3duLiBBIHZhbGlkIHN0cmluZyBleGFtcGxlOiBgQGJ1bmRsZS5pZGVudGlmaWVyOmNvbnRhaW5lcl90eXBlL3JlbGF0aXZlX3BhdGhfaW5fY29udGFpbmVyYFxuICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGNvbnRhaW5lclJvb3RTdXBwbGllciAtIEVpdGhlciBhIHN0cmluZywgdGhhdCBjb250YWluc1xuICogZnVsbCBwYXRoIHRvIHRoZSBtb3VudCByb290IGZvciByZWFsIGRldmljZXMgb3IgYSBmdW5jdGlvbiwgd2hpY2ggYWNjZXB0cyB0d28gcGFyYW1ldGVyc1xuICogKGJ1bmRsZSBpZGVudGlmaWVyIGFuZCBvcHRpb25hbCBjb250YWluZXIgdHlwZSkgYW5kIHJldHVybnMgZnVsbCBwYXRoIHRvIGNvbnRhaW5lclxuICogcm9vdCBmb2xkZXIgb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtLCBmb3IgU2ltdWxhdG9yXG4gKiBAcmV0dXJucyB7Q29udGFpbmVyT2JqZWN0fVxuICovXG5hc3luYyBmdW5jdGlvbiBwYXJzZUNvbnRhaW5lclBhdGggKHJlbW90ZVBhdGgsIGNvbnRhaW5lclJvb3RTdXBwbGllcikge1xuICBjb25zdCBtYXRjaCA9IENPTlRBSU5FUl9QQVRIX1BBVFRFUk4uZXhlYyhyZW1vdGVQYXRoKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBJdCBpcyBleHBlY3RlZCB0aGF0IHBhY2thZ2UgaWRlbnRpZmllciBgICtcbiAgICAgIGBzdGFydHMgd2l0aCAnJHtDT05UQUlORVJfUEFUSF9NQVJLRVJ9JyBhbmQgaXMgc2VwYXJhdGVkIGZyb20gdGhlIGAgK1xuICAgICAgYHJlbGF0aXZlIHBhdGggd2l0aCBhIHNpbmdsZSBzbGFzaC4gJyR7cmVtb3RlUGF0aH0nIGlzIGdpdmVuIGluc3RlYWRgKTtcbiAgfVxuICBsZXQgWywgYnVuZGxlSWQsIHJlbGF0aXZlUGF0aF0gPSBtYXRjaDtcbiAgbGV0IGNvbnRhaW5lclR5cGUgPSBudWxsO1xuICBjb25zdCB0eXBlU2VwYXJhdG9yUG9zID0gYnVuZGxlSWQuaW5kZXhPZihDT05UQUlORVJfVFlQRV9TRVBBUkFUT1IpO1xuICAvLyBXZSBvbmx5IGNvbnNpZGVyIGNvbnRhaW5lciB0eXBlIGV4aXN0cyBpZiBpdHMgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gIC8vIG5vdCBjb3VudGluZyB0aGUgY29sb25cbiAgaWYgKHR5cGVTZXBhcmF0b3JQb3MgPiAwICYmIHR5cGVTZXBhcmF0b3JQb3MgPCBidW5kbGVJZC5sZW5ndGggLSAxKSB7XG4gICAgY29udGFpbmVyVHlwZSA9IGJ1bmRsZUlkLnN1YnN0cmluZyh0eXBlU2VwYXJhdG9yUG9zICsgMSk7XG4gICAgbG9nLmRlYnVnKGBQYXJzZWQgY29udGFpbmVyIHR5cGU6ICR7Y29udGFpbmVyVHlwZX1gKTtcbiAgICBidW5kbGVJZCA9IGJ1bmRsZUlkLnN1YnN0cmluZygwLCB0eXBlU2VwYXJhdG9yUG9zKTtcbiAgfVxuICBpZiAoXy5pc05pbChjb250YWluZXJSb290U3VwcGxpZXIpKSB7XG4gICAgY29uc3QgcGF0aEluQ29udGFpbmVyID0gcmVsYXRpdmVQYXRoO1xuICAgIHJldHVybiB7IGJ1bmRsZUlkLCBwYXRoSW5Db250YWluZXIsIGNvbnRhaW5lclR5cGUgfTtcbiAgfVxuICBjb25zdCBjb250YWluZXJSb290ID0gXy5pc0Z1bmN0aW9uKGNvbnRhaW5lclJvb3RTdXBwbGllcilcbiAgICA/IGF3YWl0IGNvbnRhaW5lclJvb3RTdXBwbGllcihidW5kbGVJZCwgY29udGFpbmVyVHlwZSlcbiAgICA6IGNvbnRhaW5lclJvb3RTdXBwbGllcjtcbiAgY29uc3QgcGF0aEluQ29udGFpbmVyID0gcGF0aC5wb3NpeC5yZXNvbHZlKGNvbnRhaW5lclJvb3QsIHJlbGF0aXZlUGF0aCk7XG4gIHZlcmlmeUlzU3ViUGF0aChwYXRoSW5Db250YWluZXIsIGNvbnRhaW5lclJvb3QpO1xuICByZXR1cm4ge2J1bmRsZUlkLCBwYXRoSW5Db250YWluZXIsIGNvbnRhaW5lclR5cGV9O1xufVxuXG4vKipcbiAqIFNhdmUgdGhlIGdpdmVuIGJhc2U2NCBkYXRhIGNodW5rIGFzIGEgYmluYXJ5IGZpbGUgb24gdGhlIFNpbXVsYXRvciB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXZpY2UgLSBUaGUgZGV2aWNlIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgYHVkaWRgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgZGV2aWNlIElELlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggb24gdGhlIGRldmljZS4gVGhpcyB2YXJpYWJsZSBjYW4gYmUgcHJlZml4ZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGUgaWQsIHNvIHRoZW4gdGhlIGZpbGUgd2lsbCBiZSB1cGxvYWRlZCB0byB0aGUgY29ycmVzcG9uZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbiBjb250YWluZXIgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBtZWRpYSBmb2xkZXIsIGZvciBleGFtcGxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdAY29tLm15YXBwLmJsYTpkYXRhL1JlbGF0aXZlUGF0aEluQ29udGFpbmVyLzExMS5wbmcnLiBUaGUgJ0AnIGNoYXJhY3RlciBhdCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW5uaW5nIG9mIHRoZSBhcmd1bWVudCBpcyBtYW5kYXRvcnkgaW4gc3VjaCBjYXNlLiBUaGUgY29sb24gYXQgdGhlIGVuZCBvZiBidW5kbGUgaWRlbnRpZmllclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBvcHRpb25hbCBhbmQgaXMgdXNlZCB0byBkaXN0aW5ndWlzaCB0aGUgY29udGFpbmVyIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvc3NpYmxlIHZhbHVlcyB0aGVyZSBhcmUgJ2FwcCcsICdkYXRhJywgJ2dyb3VwcycsICc8QSBzcGVjaWZpYyBBcHAgR3JvdXAgY29udGFpbmVyPicuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHZhbHVlIGlzICdhcHAnLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgcmVsYXRpdmUgZm9sZGVyIHBhdGggaXMgaWdub3JlZCBpZiB0aGUgZmlsZSBpcyBnb2luZyB0byBiZSB1cGxvYWRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB0aGUgZGVmYXVsdCBtZWRpYSBmb2xkZXIgYW5kIG9ubHkgdGhlIGZpbGUgbmFtZSBpcyBjb25zaWRlcmVkIGltcG9ydGFudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjREYXRhIC0gQmFzZS02NCBlbmNvZGVkIGNvbnRlbnQgb2YgdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1c2hGaWxlVG9TaW11bGF0b3IgKGRldmljZSwgcmVtb3RlUGF0aCwgYmFzZTY0RGF0YSkge1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShiYXNlNjREYXRhLCAnYmFzZTY0Jyk7XG4gIGlmIChDT05UQUlORVJfUEFUSF9QQVRURVJOLnRlc3QocmVtb3RlUGF0aCkpIHtcbiAgICBjb25zdCB7IGJ1bmRsZUlkLCBwYXRoSW5Db250YWluZXI6IGRzdFBhdGggfSA9IGF3YWl0IHBhcnNlQ29udGFpbmVyUGF0aChyZW1vdGVQYXRoLFxuICAgICAgYXN5bmMgKGFwcEJ1bmRsZSwgY29udGFpbmVyVHlwZSkgPT4gYXdhaXQgZ2V0QXBwQ29udGFpbmVyKGRldmljZS51ZGlkLCBhcHBCdW5kbGUsIG51bGwsIGNvbnRhaW5lclR5cGUpKTtcbiAgICBsb2cuaW5mbyhgUGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyICcke2J1bmRsZUlkfScgZnJvbSAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgYFdpbGwgcHV0IHRoZSBkYXRhIGludG8gJyR7ZHN0UGF0aH0nYCk7XG4gICAgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aC5kaXJuYW1lKGRzdFBhdGgpKSkge1xuICAgICAgbG9nLmRlYnVnKGBUaGUgZGVzdGluYXRpb24gZm9sZGVyICcke3BhdGguZGlybmFtZShkc3RQYXRoKX0nIGRvZXMgbm90IGV4aXN0LiBDcmVhdGluZy4uLmApO1xuICAgICAgYXdhaXQgbWtkaXJwKHBhdGguZGlybmFtZShkc3RQYXRoKSk7XG4gICAgfVxuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCBidWZmZXIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkc3RGb2xkZXIgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucmVzb2x2ZShkc3RGb2xkZXIsIHBhdGguYmFzZW5hbWUocmVtb3RlUGF0aCkpO1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCBidWZmZXIpO1xuICAgIGF3YWl0IGFkZE1lZGlhKGRldmljZS51ZGlkLCBkc3RQYXRoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYoZHN0Rm9sZGVyKTtcbiAgfVxufVxuXG4vKipcbiAqIFNhdmUgdGhlIGdpdmVuIGJhc2U2NCBkYXRhIGNodW5rIGFzIGEgYmluYXJ5IGZpbGUgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXZpY2UgLSBUaGUgZGV2aWNlIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgYHVkaWRgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgZGV2aWNlIElELlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggb24gdGhlIGRldmljZS4gVGhpcyB2YXJpYWJsZSBjYW4gYmUgcHJlZml4ZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGUgaWQsIHNvIHRoZW4gdGhlIGZpbGUgd2lsbCBiZSB1cGxvYWRlZCB0byB0aGUgY29ycmVzcG9uZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbiBjb250YWluZXIgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBtZWRpYSBmb2xkZXIuIFVzZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAPGFwcF9idW5kbGVfaWQ+OjxvcHRpb25hbF9jb250YWluZXJfdHlwZT4vPHBhdGhfdG9fdGhlX2ZpbGVfb3JfZm9sZGVyX2luc2lkZV9jb250YWluZXI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCB0byBwdWxsIGEgZmlsZSBvciBhIGZvbGRlciBmcm9tIGFuIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9ubHkgc3VwcG9ydGVkIGNvbnRhaW5lciB0eXBlIGlzICdkb2N1bWVudHMnLiBJZiB0aGUgY29udGFpbmVyIHR5cGUgaXMgbm90IHNldFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBsaWNpdGx5IGZvciBhIGJ1bmRsZSBpZCwgdGhlbiB0aGUgZGVmYXVsdCBhcHBsaWNhdGlvbiBjb250YWluZXIgaXMgZ29pbmcgdG8gYmUgbW91bnRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYWthIC0tY29udGFpbmVyIGlmdXNlIGFyZ3VtZW50KVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmcuIElmIGBAY29tLm15YXBwLmJsYTpkb2N1bWVudHMvMTExLnBuZ2AgaXMgcHJvdmlkZWQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9uIE15IGlQaG9uZS88YXBwIG5hbWU+YCBpbiBGaWxlcyBhcHAgd2lsbCBiZSBtb3VudGVkIGluIHRoZSBob3N0IG1hY2hpbmUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQmFzZTY0IGVuY29kZWQgYDExMS5wbmdgIHdpbGwgYmUgcHVzaGVkIGludG8gYE9uIE15IGlQaG9uZS88YXBwIG5hbWU+LzExMS5wbmdgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgYmFzZTY0IGRlY29kZWQgZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjREYXRhIC0gQmFzZS02NCBlbmNvZGVkIGNvbnRlbnQgb2YgdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1c2hGaWxlVG9SZWFsRGV2aWNlIChkZXZpY2UsIHJlbW90ZVBhdGgsIGJhc2U2NERhdGEpIHtcbiAgY29uc3QgeyBzZXJ2aWNlLCByZWxhdGl2ZVBhdGggfSA9IGF3YWl0IGNyZWF0ZVNlcnZpY2UoZGV2aWNlLnVkaWQsIHJlbW90ZVBhdGgpO1xuICB0cnkge1xuICAgIGF3YWl0IG1rZGlycERldmljZShzZXJ2aWNlLCBwYXRoLmRpcm5hbWUocmVsYXRpdmVQYXRoKSk7XG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgc2VydmljZS5jcmVhdGVXcml0ZVN0cmVhbShyZWxhdGl2ZVBhdGgsIHsgYXV0b0Nsb3NlOiB0cnVlIH0pO1xuICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShiYXNlNjREYXRhLCAnYmFzZTY0JykpO1xuICAgIGNvbnN0IGNsb3NlRXZlbnQgPSBuZXcgQigocmVzb2x2ZSkgPT4gc3RyZWFtLm9uKCdjbG9zZScsIHJlc29sdmUpKTtcbiAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgIGF3YWl0IGNsb3NlRXZlbnQ7XG4gIH0gZmluYWxseSB7XG4gICAgc2VydmljZS5jbG9zZSgpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZW50IG9mIGdpdmVuIGZpbGUgb3IgZm9sZGVyIGZyb20gaU9TIFNpbXVsYXRvciBhbmQgcmV0dXJuIGl0IGFzIGJhc2UtNjQgZW5jb2RlZCBzdHJpbmcuXG4gKiBGb2xkZXIgY29udGVudCBpcyByZWN1cnNpdmVseSBwYWNrZWQgaW50byBhIHppcCBhcmNoaXZlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXZpY2UgLSBUaGUgZGV2aWNlIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgYHVkaWRgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgZGV2aWNlIElELlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcGF0aCB0byBhIGZpbGUgb3IgYSBmb2xkZXIsIHdoaWNoIGV4aXN0cyBpbiB0aGUgY29ycmVzcG9uZGluZyBhcHBsaWNhdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgb24gU2ltdWxhdG9yLiBVc2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQDxhcHBfYnVuZGxlX2lkPjo8b3B0aW9uYWxfY29udGFpbmVyX3R5cGU+LzxwYXRoX3RvX3RoZV9maWxlX29yX2ZvbGRlcl9pbnNpZGVfY29udGFpbmVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgdG8gcHVsbCBhIGZpbGUgb3IgYSBmb2xkZXIgZnJvbSBhbiBhcHBsaWNhdGlvbiBjb250YWluZXIgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvc3NpYmxlIGNvbnRhaW5lciB0eXBlcyBhcmUgJ2FwcCcsICdkYXRhJywgJ2dyb3VwcycsICc8QSBzcGVjaWZpYyBBcHAgR3JvdXAgY29udGFpbmVyPicuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHR5cGUgaXMgJ2FwcCcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRmlsZSAtIFdoZXRoZXIgdGhlIGRlc3RpbmF0aW9uIGl0ZW0gaXMgYSBmaWxlIG9yIGEgZm9sZGVyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlLTY0IGVuY29kZWQgY29udGVudCBvZiB0aGUgZmlsZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHVsbEZyb21TaW11bGF0b3IgKGRldmljZSwgcmVtb3RlUGF0aCwgaXNGaWxlKSB7XG4gIGxldCBwYXRoT25TZXJ2ZXI7XG4gIGlmIChDT05UQUlORVJfUEFUSF9QQVRURVJOLnRlc3QocmVtb3RlUGF0aCkpIHtcbiAgICBjb25zdCB7IGJ1bmRsZUlkLCBwYXRoSW5Db250YWluZXI6IGRzdFBhdGggfSA9IGF3YWl0IHBhcnNlQ29udGFpbmVyUGF0aChyZW1vdGVQYXRoLFxuICAgICAgYXN5bmMgKGFwcEJ1bmRsZSwgY29udGFpbmVyVHlwZSkgPT4gYXdhaXQgZ2V0QXBwQ29udGFpbmVyKGRldmljZS51ZGlkLCBhcHBCdW5kbGUsIG51bGwsIGNvbnRhaW5lclR5cGUpKTtcbiAgICBsb2cuaW5mbyhgUGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyICcke2J1bmRsZUlkfScgZnJvbSAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgYFdpbGwgZ2V0IHRoZSBkYXRhIGZyb20gJyR7ZHN0UGF0aH0nYCk7XG4gICAgcGF0aE9uU2VydmVyID0gZHN0UGF0aDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzaW1Sb290ID0gZGV2aWNlLmdldERpcigpO1xuICAgIHBhdGhPblNlcnZlciA9IHBhdGgucG9zaXguam9pbihzaW1Sb290LCByZW1vdGVQYXRoKTtcbiAgICB2ZXJpZnlJc1N1YlBhdGgocGF0aE9uU2VydmVyLCBzaW1Sb290KTtcbiAgICBsb2cuaW5mbyhgR290IHRoZSBmdWxsIGl0ZW0gcGF0aDogJHtwYXRoT25TZXJ2ZXJ9YCk7XG4gIH1cbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aE9uU2VydmVyKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBUaGUgcmVtb3RlICR7aXNGaWxlID8gJ2ZpbGUnIDogJ2ZvbGRlcid9IGF0ICcke3BhdGhPblNlcnZlcn0nIGRvZXMgbm90IGV4aXN0YCk7XG4gIH1cbiAgY29uc3QgYnVmZmVyID0gaXNGaWxlXG4gICAgPyBhd2FpdCBmcy5yZWFkRmlsZShwYXRoT25TZXJ2ZXIpXG4gICAgOiBhd2FpdCB6aXAudG9Jbk1lbW9yeVppcChwYXRoT25TZXJ2ZXIpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZW50IG9mIGdpdmVuIGZpbGUgb3IgZm9sZGVyIGZyb20gdGhlIHJlYWwgZGV2aWNlIHVuZGVyIHRlc3QgYW5kIHJldHVybiBpdCBhcyBiYXNlLTY0IGVuY29kZWQgc3RyaW5nLlxuICogRm9sZGVyIGNvbnRlbnQgaXMgcmVjdXJzaXZlbHkgcGFja2VkIGludG8gYSB6aXAgYXJjaGl2ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gYW4gZXhpc3RpbmcgcmVtb3RlIGZpbGUgb24gdGhlIGRldmljZS4gVGhpcyB2YXJpYWJsZSBjYW4gYmUgcHJlZml4ZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGUgaWQsIHNvIHRoZW4gdGhlIGZpbGUgd2lsbCBiZSBkb3dubG9hZGVkIGZyb20gdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyLiBVc2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQDxhcHBfYnVuZGxlX2lkPjo8b3B0aW9uYWxfY29udGFpbmVyX3R5cGU+LzxwYXRoX3RvX3RoZV9maWxlX29yX2ZvbGRlcl9pbnNpZGVfY29udGFpbmVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgdG8gcHVsbCBhIGZpbGUgb3IgYSBmb2xkZXIgZnJvbSBhbiBhcHBsaWNhdGlvbiBjb250YWluZXIgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvbmx5IHN1cHBvcnRlZCBjb250YWluZXIgdHlwZSBpcyAnZG9jdW1lbnRzJy4gSWYgdGhlIGNvbnRhaW5lciB0eXBlIGlzIG5vdCBzZXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwbGljaXRseSBmb3IgYSBidW5kbGUgaWQsIHRoZW4gdGhlIGRlZmF1bHQgYXBwbGljYXRpb24gY29udGFpbmVyIGlzIGdvaW5nIHRvIGJlIG1vdW50ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFrYSAtLWNvbnRhaW5lciBpZnVzZSBhcmd1bWVudClcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5nLiBJZiBgQGNvbS5teWFwcC5ibGE6ZG9jdW1lbnRzLzExMS5wbmdgIGlzIHByb3ZpZGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPmAgaW4gRmlsZXMgYXBwIHdpbGwgYmUgbW91bnRlZCBpbiB0aGUgaG9zdCBtYWNoaW5lLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPi8xMTEucG5nYCB3aWwgYmUgcHVsbGVkIGludG8gdGhlIG1vdW50ZWQgaG9zdCBtYWNoaW5lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIEFwcGl1bSByZXR1cm5zIHRoZSBkYXRhIGFzIGJhc2U2NC1lbmNvZGVkIHN0cmluZyB0byBjbGllbnQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYEBjb20ubXlhcHAuYmxhOmRvY3VtZW50cy9gIG1lYW5zIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPmAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRmlsZSAtIFdoZXRoZXIgdGhlIGRlc3RpbmF0aW9uIGl0ZW0gaXMgYSBmaWxlIG9yIGEgZm9sZGVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2UtNjQgZW5jb2RlZCBjb250ZW50IG9mIHRoZSByZW1vdGUgZmlsZVxuICovXG5hc3luYyBmdW5jdGlvbiBwdWxsRnJvbVJlYWxEZXZpY2UgKGRldmljZSwgcmVtb3RlUGF0aCwgaXNGaWxlKSB7XG4gIGF3YWl0IHZlcmlmeUlGdXNlUHJlc2VuY2UoKTtcbiAgY29uc3QgbW50Um9vdCA9IGF3YWl0IHRlbXBEaXIub3BlbkRpcigpO1xuICBsZXQgaXNVbm1vdW50U3VjY2Vzc2Z1bCA9IHRydWU7XG4gIHRyeSB7XG4gICAgbGV0IGRzdFBhdGggPSBwYXRoLnJlc29sdmUobW50Um9vdCwgcmVtb3RlUGF0aCk7XG4gICAgbGV0IGlmdXNlQXJncyA9IFsnLXUnLCBkZXZpY2UudWRpZCwgbW50Um9vdF07XG4gICAgaWYgKENPTlRBSU5FUl9QQVRIX1BBVFRFUk4udGVzdChyZW1vdGVQYXRoKSkge1xuICAgICAgY29uc3QgeyBidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyLCBjb250YWluZXJUeXBlIH0gPSBhd2FpdCBwYXJzZUNvbnRhaW5lclBhdGgocmVtb3RlUGF0aCwgbW50Um9vdCk7XG4gICAgICBkc3RQYXRoID0gcGF0aEluQ29udGFpbmVyO1xuICAgICAgbG9nLmluZm8oYFBhcnNlZCBidW5kbGUgaWRlbnRpZmllciAnJHtidW5kbGVJZH0nIGZyb20gJyR7cmVtb3RlUGF0aH0nLiBgICtcbiAgICAgICAgYFdpbGwgZ2V0IHRoZSBkYXRhIGZyb20gJyR7ZHN0UGF0aH0nYCk7XG4gICAgICBpZnVzZUFyZ3MgPSBbXG4gICAgICAgICctdScsXG4gICAgICAgIGRldmljZS51ZGlkLFxuICAgICAgICBpc0RvY3VtZW50cyhjb250YWluZXJUeXBlKSA/ICctLWRvY3VtZW50cycgOiAnLS1jb250YWluZXInLFxuICAgICAgICBidW5kbGVJZCxcbiAgICAgICAgbW50Um9vdFxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVyaWZ5SXNTdWJQYXRoKGRzdFBhdGgsIG1udFJvb3QpO1xuICAgIH1cbiAgICBhd2FpdCBtb3VudERldmljZShkZXZpY2UsIGlmdXNlQXJncyk7XG4gICAgaXNVbm1vdW50U3VjY2Vzc2Z1bCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhkc3RQYXRoKSkge1xuICAgICAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVGhlIHJlbW90ZSAke2lzRmlsZSA/ICdmaWxlJyA6ICdmb2xkZXInfSBhdCAnJHtkc3RQYXRofScgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGlzRmlsZVxuICAgICAgICA/IGF3YWl0IGZzLnJlYWRGaWxlKGRzdFBhdGgpXG4gICAgICAgIDogYXdhaXQgemlwLnRvSW5NZW1vcnlaaXAoZHN0UGF0aCk7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIFJhcmVseSB1bW91bnQgZmFpbHMsIHNvIHJldHJ5IG9uY2VcbiAgICAgIHJldHJ5KDIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXdhaXQgZXhlYygndW1vdW50JywgW21udFJvb3RdKTtcbiAgICAgIH0pO1xuICAgICAgaXNVbm1vdW50U3VjY2Vzc2Z1bCA9IHRydWU7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChpc1VubW91bnRTdWNjZXNzZnVsKSB7XG4gICAgICBhd2FpdCBmcy5yaW1yYWYobW50Um9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy53YXJuKGBVbW91bnQgaGFzIGZhaWxlZCwgc28gbm90IHJlbW92aW5nICcke21udFJvb3R9J2ApO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogR2V0IGJ1bmRsZUlkcyB3aGljaCBjYW4gbW91bnQgYnkgYC0tZG9jdW1lbnRzYCBmbGFnXG4gKlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB1ZGlkIC0gVGhlIHVkaWQgb2YgdGhlIHRhcmdldCBkZXZpY2VcbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBBIGxpc3Qgb2YgVXNlciBsZXZlbCBhcHBzJyBidW5kbGUgaWRzIHdoaWNoIGhhc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICdVSUZpbGVTaGFyaW5nRW5hYmxlZCcgYXR0cmlidXRlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgdXNlciBhcHBzIG1pZ2h0IGhhdmUgaXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEF2YWlsYWJsZUJ1bmRsZUlkcyAodWRpZCkge1xuICBjb25zdCBzZXJ2aWNlID0gYXdhaXQgc2VydmljZXMuc3RhcnRJbnN0YWxsYXRpb25Qcm94eVNlcnZpY2UodWRpZCk7XG4gIHRyeSB7XG4gICAgY29uc3QgYXBwbGljYXRpb25zID0gYXdhaXQgc2VydmljZS5saXN0QXBwbGljYXRpb25zKHthcHBsaWNhdGlvblR5cGU6ICdVc2VyJ30pO1xuICAgIGNvbnN0IGJ1bmRsZUlkcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFwcGxpY2F0aW9ucykpIHtcbiAgICAgIGlmICghdmFsdWUuVUlGaWxlU2hhcmluZ0VuYWJsZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBidW5kbGVJZHMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gYnVuZGxlSWRzO1xuICB9IGZpbmFsbHkge1xuICAgIHNlcnZpY2UuY2xvc2UoKTtcbiAgfVxufVxuXG5cbmNvbW1hbmRzLnB1c2hGaWxlID0gYXN5bmMgZnVuY3Rpb24gcHVzaEZpbGUgKHJlbW90ZVBhdGgsIGJhc2U2NERhdGEpIHtcbiAgaWYgKHJlbW90ZVBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBJdCBpcyBleHBlY3RlZCB0aGF0IHJlbW90ZSBwYXRoIHBvaW50cyB0byBhIGZpbGUgYW5kIG5vdCB0byBhIGZvbGRlci4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYCcke3JlbW90ZVBhdGh9JyBpcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgaWYgKF8uaXNBcnJheShiYXNlNjREYXRhKSkge1xuICAgIC8vIHNvbWUgY2xpZW50cyAoYWhlbSkgamF2YSwgc2VuZCBhIGJ5dGUgYXJyYXkgZW5jb2RpbmcgdXRmOCBjaGFyYWN0ZXJzXG4gICAgLy8gaW5zdGVhZCBvZiBhIHN0cmluZywgd2hpY2ggd291bGQgYmUgaW5maW5pdGVseSBiZXR0ZXIhXG4gICAgYmFzZTY0RGF0YSA9IEJ1ZmZlci5mcm9tKGJhc2U2NERhdGEpLnRvU3RyaW5nKCd1dGY4Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaXNTaW11bGF0b3IoKVxuICAgID8gYXdhaXQgcHVzaEZpbGVUb1NpbXVsYXRvcih0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCBiYXNlNjREYXRhKVxuICAgIDogYXdhaXQgcHVzaEZpbGVUb1JlYWxEZXZpY2UodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgYmFzZTY0RGF0YSk7XG59O1xuXG5jb21tYW5kcy5wdWxsRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIHB1bGxGaWxlIChyZW1vdGVQYXRoKSB7XG4gIGlmIChyZW1vdGVQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgSXQgaXMgZXhwZWN0ZWQgdGhhdCByZW1vdGUgcGF0aCBwb2ludHMgdG8gYSBmaWxlIGFuZCBub3QgdG8gYSBmb2xkZXIuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGAnJHtyZW1vdGVQYXRofScgaXMgZ2l2ZW4gaW5zdGVhZGApO1xuICB9XG4gIHJldHVybiB0aGlzLmlzU2ltdWxhdG9yKClcbiAgICA/IGF3YWl0IHB1bGxGcm9tU2ltdWxhdG9yKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIHRydWUpXG4gICAgOiBhd2FpdCBwdWxsRnJvbVJlYWxEZXZpY2UodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgdHJ1ZSk7XG59O1xuXG5jb21tYW5kcy5nZXRTaW1GaWxlRnVsbFBhdGggPSBhc3luYyBmdW5jdGlvbiBnZXRTaW1GaWxlRnVsbFBhdGggKHJlbW90ZVBhdGgpIHtcbiAgbGV0IGJhc2VQYXRoID0gdGhpcy5vcHRzLmRldmljZS5nZXREaXIoKTtcbiAgbGV0IGFwcE5hbWUgPSBudWxsO1xuXG4gIGlmICh0aGlzLm9wdHMuYXBwKSB7XG4gICAgbGV0IGFwcE5hbWVSZWdleCA9IG5ldyBSZWdFeHAoYFxcXFwke3BhdGguc2VwfShbXFxcXHctXStcXFxcLmFwcClgKTtcbiAgICBsZXQgYXBwTmFtZU1hdGNoZXMgPSBhcHBOYW1lUmVnZXguZXhlYyh0aGlzLm9wdHMuYXBwKTtcbiAgICBpZiAoYXBwTmFtZU1hdGNoZXMpIHtcbiAgICAgIGFwcE5hbWUgPSBhcHBOYW1lTWF0Y2hlc1sxXTtcbiAgICB9XG4gIH1cbiAgLy8gZGUtYWJzb2x1dGl6ZSB0aGUgcGF0aFxuICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgaWYgKHJlbW90ZVBhdGguaW5kZXhvZignOi8vJykgPT09IDEpIHtcbiAgICAgIHJlbW90ZVBhdGggPSByZW1vdGVQYXRoLnNsaWNlKDQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocmVtb3RlUGF0aC5pbmRleE9mKCcvJykgPT09IDApIHtcbiAgICAgIHJlbW90ZVBhdGggPSByZW1vdGVQYXRoLnNsaWNlKDEpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZW1vdGVQYXRoLnN0YXJ0c1dpdGgoYXBwTmFtZSkpIHtcbiAgICBsZXQgZmluZFBhdGggPSBiYXNlUGF0aDtcbiAgICBpZiAoIXRoaXMub3B0cy5wbGF0Zm9ybVZlcnNpb24gfHwgdXRpbC5jb21wYXJlVmVyc2lvbnModGhpcy5vcHRzLnBsYXRmb3JtVmVyc2lvbiwgJz49JywgJzguMCcpKSB7XG4gICAgICAvLyB0aGUgLmFwcCBmaWxlIGFwcGVhcnMgaW4gL0NvbnRhaW5lcnMvRGF0YSBhbmQgL0NvbnRhaW5lcnMvQnVuZGxlIGJvdGguIFdlIG9ubHkgd2FudCAvQnVuZGxlXG4gICAgICBmaW5kUGF0aCA9IHBhdGgucmVzb2x2ZShiYXNlUGF0aCwgJ0NvbnRhaW5lcnMnLCAnQnVuZGxlJyk7XG4gICAgfVxuICAgIGZpbmRQYXRoID0gZmluZFBhdGgucmVwbGFjZSgvXFxzL2csICdcXFxcICcpO1xuXG4gICAgbGV0IHsgc3Rkb3V0IH0gPSBhd2FpdCBleGVjKCdmaW5kJywgW2ZpbmRQYXRoLCAnLW5hbWUnLCBhcHBOYW1lXSk7XG4gICAgbGV0IGFwcFJvb3QgPSBzdGRvdXQucmVwbGFjZSgvXFxuJC8sICcnKTtcbiAgICBsZXQgc3ViUGF0aCA9IHJlbW90ZVBhdGguc3Vic3RyaW5nKGFwcE5hbWUubGVuZ3RoICsgMSk7XG4gICAgbGV0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKGFwcFJvb3QsIHN1YlBhdGgpO1xuICAgIGxvZy5kZWJ1ZyhgRmluZGluZyBhcHAtcmVsYXRpdmUgZmlsZTogJyR7ZnVsbFBhdGh9J2ApO1xuICAgIHJldHVybiBmdWxsUGF0aDtcbiAgfVxuXG4gIGxldCBmdWxsUGF0aCA9IHBhdGgucmVzb2x2ZShiYXNlUGF0aCwgcmVtb3RlUGF0aCk7XG4gIGxvZy5kZWJ1ZyhgRmluZGluZyBzaW0tcmVsYXRpdmUgZmlsZTogJHtmdWxsUGF0aH1gKTtcbiAgcmV0dXJuIGZ1bGxQYXRoO1xufTtcblxuY29tbWFuZHMucHVsbEZvbGRlciA9IGFzeW5jIGZ1bmN0aW9uIHB1bGxGb2xkZXIgKHJlbW90ZVBhdGgpIHtcbiAgaWYgKCFyZW1vdGVQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICByZW1vdGVQYXRoID0gYCR7cmVtb3RlUGF0aH0vYDtcbiAgfVxuICByZXR1cm4gdGhpcy5pc1NpbXVsYXRvcigpXG4gICAgPyBhd2FpdCBwdWxsRnJvbVNpbXVsYXRvcih0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCBmYWxzZSlcbiAgICA6IGF3YWl0IHB1bGxGcm9tUmVhbERldmljZSh0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCBmYWxzZSk7XG59O1xuXG5leHBvcnQgeyBjb21tYW5kcywgLyogZm9yIHRlc3RpbmcgKi8gZ2V0QXZhaWxhYmxlQnVuZGxlSWRzLFxuICAvKiBmb3IgdGVzdGluZyAqLyBwYXJzZUNvbnRhaW5lclBhdGggfTtcbmV4cG9ydCBkZWZhdWx0IGNvbW1hbmRzO1xuIl0sImZpbGUiOiJsaWIvY29tbWFuZHMvZmlsZS1tb3ZlbWVudC5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9

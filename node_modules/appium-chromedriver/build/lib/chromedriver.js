"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMostRecentChromedriver = getMostRecentChromedriver;
exports.default = exports.CD_VER = exports.CHROMEDRIVER_CHROME_MAPPING = exports.Chromedriver = void 0;

require("source-map-support/register");

var _events = _interopRequireDefault(require("events"));

var _appiumBaseDriver = require("appium-base-driver");

var _child_process = _interopRequireDefault(require("child_process"));

var _appiumSupport = require("appium-support");

var _asyncbox = require("asyncbox");

var _teen_process = require("teen_process");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _utils = require("./utils");

var _semver = _interopRequireDefault(require("semver"));

var _lodash = _interopRequireDefault(require("lodash"));

var _path = _interopRequireDefault(require("path"));

var _compareVersions = _interopRequireDefault(require("compare-versions"));

var _storageClient = _interopRequireDefault(require("./storage-client"));

const log = _appiumSupport.logger.getLogger('Chromedriver');

const NEW_CD_VERSION_FORMAT_MAJOR_VERSION = 73;
const DEFAULT_HOST = '127.0.0.1';
const DEFAULT_PORT = 9515;
const CHROMEDRIVER_CHROME_MAPPING = {
  '75.0.3770.90': '75.0.3770.90',
  '75.0.3770.8': '75.0.3770.8',
  '74.0.3729.6': '74.0.3729',
  '73.0.3683.68': '70.0.3538',
  '2.46': '71.0.3578',
  '2.45': '70.0.0',
  '2.44': '69.0.3497',
  '2.43': '69.0.3497',
  '2.42': '68.0.3440',
  '2.41': '67.0.3396',
  '2.40': '66.0.3359',
  '2.39': '66.0.3359',
  '2.38': '65.0.3325',
  '2.37': '64.0.3282',
  '2.36': '63.0.3239',
  '2.35': '62.0.3202',
  '2.34': '61.0.3163',
  '2.33': '60.0.3112',
  '2.32': '59.0.3071',
  '2.31': '58.0.3029',
  '2.30': '58.0.3029',
  '2.29': '57.0.2987',
  '2.28': '55.0.2883',
  '2.27': '54.0.2840',
  '2.26': '53.0.2785',
  '2.25': '53.0.2785',
  '2.24': '52.0.2743',
  '2.23': '51.0.2704',
  '2.22': '49.0.2623',
  '2.21': '46.0.2490',
  '2.20': '43.0.2357',
  '2.19': '43.0.2357',
  '2.18': '43.0.2357',
  '2.17': '42.0.2311',
  '2.16': '42.0.2311',
  '2.15': '40.0.2214',
  '2.14': '39.0.2171',
  '2.13': '38.0.2125',
  '2.12': '36.0.1985',
  '2.11': '36.0.1985',
  '2.10': '33.0.1751',
  '2.9': '31.0.1650',
  '2.8': '30.0.1573',
  '2.7': '30.0.1573',
  '2.6': '29.0.1545',
  '2.5': '29.0.1545',
  '2.4': '29.0.1545',
  '2.3': '28.0.1500',
  '2.2': '27.0.1453',
  '2.1': '27.0.1453',
  '2.0': '27.0.1453'
};
exports.CHROMEDRIVER_CHROME_MAPPING = CHROMEDRIVER_CHROME_MAPPING;
const CHROME_BUNDLE_ID = 'com.android.chrome';
const WEBVIEW_BUNDLE_IDS = ['com.google.android.webview', 'com.android.webview'];
const CHROMEDRIVER_TUTORIAL = 'https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/web/chromedriver.md';
const CD_VER = process.env.npm_config_chromedriver_version || process.env.CHROMEDRIVER_VERSION || getMostRecentChromedriver();
exports.CD_VER = CD_VER;
const CD_VERSION_TIMEOUT = 5000;

function getMostRecentChromedriver(mapping = CHROMEDRIVER_CHROME_MAPPING) {
  if (_lodash.default.isEmpty(mapping)) {
    throw new Error('Unable to get most recent Chromedriver from empty mapping');
  }

  return _lodash.default.last(_lodash.default.keys(mapping).sort(_compareVersions.default));
}

class Chromedriver extends _events.default.EventEmitter {
  constructor(args = {}) {
    super();
    const {
      host = DEFAULT_HOST,
      port = DEFAULT_PORT,
      useSystemExecutable = false,
      executable,
      executableDir = (0, _utils.getChromedriverDir)(),
      bundleId,
      mappingPath,
      cmdArgs,
      adb,
      verbose,
      logPath,
      disableBuildCheck,
      isAutodownloadEnabled = false
    } = args;
    this.proxyHost = host;
    this.proxyPort = port;
    this.adb = adb;
    this.cmdArgs = cmdArgs;
    this.proc = null;
    this.useSystemExecutable = useSystemExecutable;
    this.chromedriver = executable;
    this.executableDir = executableDir;
    this.mappingPath = mappingPath;
    this.bundleId = bundleId;
    this.executableVerified = false;
    this.state = Chromedriver.STATE_STOPPED;
    this.jwproxy = new _appiumBaseDriver.JWProxy({
      server: this.proxyHost,
      port: this.proxyPort
    });
    this.verbose = verbose;
    this.logPath = logPath;
    this.disableBuildCheck = !!disableBuildCheck;
    this.storageClient = isAutodownloadEnabled ? new _storageClient.default({
      chromedriverDir: this.executableDir
    }) : null;
  }

  async getMapping() {
    let mapping = CHROMEDRIVER_CHROME_MAPPING;

    if (this.mappingPath) {
      log.debug(`Attempting to use Chromedriver-Chrome mapping from '${this.mappingPath}'`);

      if (!(await _appiumSupport.fs.exists(this.mappingPath))) {
        log.warn(`No file found at '${this.mappingPath}'. Using default mapping`);
      } else {
        try {
          mapping = JSON.parse((await _appiumSupport.fs.readFile(this.mappingPath)));
        } catch (err) {
          log.error(`Error parsing mapping from '${this.mappingPath}': ${err.message}`);
          log.warn('Using default mapping');
        }
      }
    }

    for (const [cdVersion, chromeVersion] of _lodash.default.toPairs(mapping)) {
      mapping[cdVersion] = _semver.default.coerce(chromeVersion);
    }

    return mapping;
  }

  async getChromedrivers(mapping) {
    const executables = await _appiumSupport.fs.glob(`${this.executableDir}/*`);
    log.debug(`Found ${executables.length} executable${executables.length === 1 ? '' : 's'} ` + `in '${this.executableDir}'`);
    const cds = (await (0, _asyncbox.asyncmap)(executables, async function mapChromedriver(executable) {
      const logError = ({
        message,
        stdout = null,
        stderr = null
      }) => {
        let errMsg = `Cannot retrieve version number from '${_path.default.basename(executable)}' Chromedriver binary. ` + `Make sure it returns a valid version string in response to '--version' command line argument. ${message}`;

        if (stdout) {
          errMsg += `\nStdout: ${stdout}`;
        }

        if (stderr) {
          errMsg += `\nStderr: ${stderr}`;
        }

        log.warn(errMsg);
        return null;
      };

      let stdout;
      let stderr;

      try {
        ({
          stdout,
          stderr
        } = await (0, _teen_process.exec)(executable, ['--version'], {
          timeout: CD_VERSION_TIMEOUT
        }));
      } catch (err) {
        if (!(err.message || '').includes('timed out') && !(err.stdout || '').includes('Starting ChromeDriver')) {
          return logError(err);
        }

        stdout = err.stdout;
      }

      const match = /ChromeDriver\s+\(?v?([\d.]+)\)?/i.exec(stdout);

      if (!match) {
        return logError({
          message: 'Cannot parse the version string',
          stdout,
          stderr
        });
      }

      let version = match[1];

      const coercedVersion = _semver.default.coerce(version, true);

      if (coercedVersion) {
        if (coercedVersion.major < NEW_CD_VERSION_FORMAT_MAJOR_VERSION) {
          version = `${coercedVersion.major}.${coercedVersion.minor}`;
        }
      }

      return {
        executable,
        version,
        minChromeVersion: mapping[version]
      };
    })).filter(cd => !!cd).sort((a, b) => (0, _compareVersions.default)(b.version, a.version));

    if (_lodash.default.isEmpty(cds)) {
      log.errorAndThrow(`No Chromedrivers found in '${this.executableDir}'`);
    }

    log.debug(`The following Chromedriver executables were found:`);

    for (const cd of cds) {
      log.debug(`    '${cd.executable}' (version '${cd.version}', minimum Chrome version '${cd.minChromeVersion ? cd.minChromeVersion : 'Unknown'}')`);
    }

    return cds;
  }

  async getChromeVersion() {
    let chromeVersion;

    if (this.adb && (await this.adb.getApiLevel()) >= 24) {
      this.bundleId = CHROME_BUNDLE_ID;
    }

    if (!this.bundleId) {
      this.bundleId = CHROME_BUNDLE_ID;

      for (const bundleId of WEBVIEW_BUNDLE_IDS) {
        chromeVersion = await (0, _utils.getChromeVersion)(this.adb, bundleId);

        if (chromeVersion) {
          this.bundleId = bundleId;
          break;
        }
      }
    }

    if (!chromeVersion) {
      chromeVersion = await (0, _utils.getChromeVersion)(this.adb, this.bundleId);
    }

    return chromeVersion ? _semver.default.coerce(chromeVersion) : null;
  }

  async getCompatibleChromedriver() {
    if (!this.adb) {
      return await (0, _utils.getChromedriverBinaryPath)();
    }

    const mapping = await this.getMapping();
    let didStorageSync = false;

    const syncChromedrivers = async chromeVersion => {
      didStorageSync = true;
      const retrievedMapping = await this.storageClient.retrieveMapping();
      log.debug('Got chromedrivers mapping from the storage: ' + JSON.stringify(retrievedMapping, null, 2));
      const driverKeys = await this.storageClient.syncDrivers({
        minBrowserVersion: chromeVersion.major
      });

      if (_lodash.default.isEmpty(driverKeys)) {
        return false;
      }

      const synchronizedDriversMapping = driverKeys.reduce((acc, x) => {
        const {
          version,
          minBrowserVersion
        } = retrievedMapping[x];
        acc[version] = minBrowserVersion;
        return acc;
      }, {});
      Object.assign(mapping, synchronizedDriversMapping);
      let shouldUpdateGlobalMapping = true;

      if (await _appiumSupport.fs.exists(this.mappingPath)) {
        try {
          await _appiumSupport.fs.writeFile(this.mappingPath, JSON.stringify(mapping, null, 2), 'utf8');
          shouldUpdateGlobalMapping = false;
        } catch (e) {
          log.warn(`Cannot store the updated chromedrivers mapping into '${this.mappingPath}'. ` + `This may reduce the performance of further executions. Original error: ${e.message}`);
        }
      }

      if (shouldUpdateGlobalMapping) {
        Object.assign(CHROMEDRIVER_CHROME_MAPPING, mapping);
      }

      return true;
    };

    do {
      const cds = await this.getChromedrivers(mapping);

      if (this.disableBuildCheck) {
        const {
          version,
          executable
        } = cds[0];
        log.warn(`Chrome build check disabled. Using most recent Chromedriver version (${version}, at '${executable}')`);
        log.warn(`If this is wrong, set 'chromedriverDisableBuildCheck' capability to 'false'`);
        return executable;
      }

      const chromeVersion = await this.getChromeVersion();

      if (!chromeVersion) {
        const {
          version,
          executable
        } = cds[0];
        log.warn(`Unable to discover Chrome version. Using Chromedriver ${version} at '${executable}'`);
        return executable;
      }

      log.debug(`Found Chrome bundle '${this.bundleId}' version '${chromeVersion}'`);
      const autodownloadMsg = this.storageClient && didStorageSync ? '' : '. You could also try to enable automated chromedrivers download server feature';

      if (_semver.default.gt(chromeVersion, _lodash.default.values(mapping)[0]) && cds[0] && !cds[0].minChromeVersion) {
        if (this.storageClient && !didStorageSync) {
          try {
            if (await syncChromedrivers(chromeVersion)) {
              continue;
            }
          } catch (e) {
            log.warn(e.stack);
          }
        }

        const {
          version,
          executable
        } = cds[0];
        log.warn(`No known Chromedriver available to automate Chrome version '${chromeVersion}'.\n` + `Using Chromedriver version '${version}', which has not been tested with Appium` + autodownloadMsg);
        return executable;
      }

      const workingCds = cds.filter(cd => {
        const versionObj = _semver.default.coerce(cd.minChromeVersion);

        return versionObj && chromeVersion.major === versionObj.major;
      });

      if (_lodash.default.isEmpty(workingCds)) {
        if (this.storageClient && !didStorageSync) {
          try {
            if (await syncChromedrivers(chromeVersion)) {
              continue;
            }
          } catch (e) {
            log.warn(e.stack);
          }
        }

        log.errorAndThrow(`No Chromedriver found that can automate Chrome '${chromeVersion}'. ` + `See ${CHROMEDRIVER_TUTORIAL} for more details` + autodownloadMsg);
      }

      const binPath = workingCds[0].executable;
      log.debug(`Found ${workingCds.length} Chromedriver executable${workingCds.length === 1 ? '' : 's'} ` + `capable of automating Chrome '${chromeVersion}'.\nChoosing the most recent, '${binPath}'.`);
      log.debug('If a specific version is required, specify it with the `chromedriverExecutable`' + 'desired capability.');
      return binPath;
    } while (true);
  }

  async initChromedriverPath() {
    if (this.executableVerified) return;

    if (!this.chromedriver) {
      this.chromedriver = this.useSystemExecutable ? await (0, _utils.getChromedriverBinaryPath)() : await this.getCompatibleChromedriver();
    }

    if (!(await _appiumSupport.fs.exists(this.chromedriver))) {
      throw new Error(`Trying to use a chromedriver binary at the path ` + `${this.chromedriver}, but it doesn't exist!`);
    }

    this.executableVerified = true;
    log.info(`Set chromedriver binary as: ${this.chromedriver}`);
  }

  async start(caps, emitStartingState = true) {
    this.capabilities = _lodash.default.cloneDeep(caps);
    this.capabilities.loggingPrefs = this.capabilities.loggingPrefs || {};

    if (_lodash.default.isEmpty(this.capabilities.loggingPrefs.browser)) {
      this.capabilities.loggingPrefs.browser = 'ALL';
    }

    if (emitStartingState) {
      this.changeState(Chromedriver.STATE_STARTING);
    }

    let args = ['--url-base=wd/hub', `--port=${this.proxyPort}`];

    if (this.adb && this.adb.adbPort) {
      args = args.concat([`--adb-port=${this.adb.adbPort}`]);
    }

    if (this.cmdArgs) {
      args = args.concat(this.cmdArgs);
    }

    if (this.logPath) {
      args = args.concat([`--log-path=${this.logPath}`]);
    }

    if (this.disableBuildCheck) {
      args = args.concat(['--disable-build-check']);
    }

    args = args.concat(['--verbose']);

    const startDetector = stdout => {
      return stdout.indexOf('Starting ') === 0;
    };

    let processIsAlive = false;
    let webviewVersion;

    try {
      await this.initChromedriverPath();
      await this.killAll();
      this.proc = new _teen_process.SubProcess(this.chromedriver, args);
      processIsAlive = true;
      this.proc.on('output', (stdout, stderr) => {
        const out = stdout + stderr;
        let match = /"Browser": "(.*)"/.exec(out);

        if (match) {
          webviewVersion = match[1];
          log.debug(`Webview version: '${webviewVersion}'`);
        }

        match = /Starting ChromeDriver ([.\d]+)/.exec(out);

        if (match) {
          log.debug(`Chromedriver version: '${match[1]}'`);
        }

        if (this.verbose) {
          for (let line of (stdout || '').trim().split('\n')) {
            if (!line.trim().length) continue;
            log.debug(`[STDOUT] ${line}`);
          }

          for (let line of (stderr || '').trim().split('\n')) {
            if (!line.trim().length) continue;
            log.error(`[STDERR] ${line}`);
          }
        }
      });
      this.proc.on('exit', (code, signal) => {
        processIsAlive = false;

        if (this.state !== Chromedriver.STATE_STOPPED && this.state !== Chromedriver.STATE_STOPPING && this.state !== Chromedriver.STATE_RESTARTING) {
          let msg = `Chromedriver exited unexpectedly with code ${code}, ` + `signal ${signal}`;
          log.error(msg);
          this.changeState(Chromedriver.STATE_STOPPED);
        }
      });
      log.info(`Spawning chromedriver with: ${this.chromedriver} ` + `${args.join(' ')}`);
      await this.proc.start(startDetector);
      await this.waitForOnline();
      await this.startSession();
    } catch (e) {
      this.emit(Chromedriver.EVENT_ERROR, e);

      if (processIsAlive) {
        await this.proc.stop();
      }

      let message = '';

      if (e.message.includes('Chrome version must be')) {
        message += 'Unable to automate Chrome version because it is too old for this version of Chromedriver.\n';

        if (webviewVersion) {
          message += `Chrome version on the device: ${webviewVersion}\n`;
        }

        message += `Visit '${CHROMEDRIVER_TUTORIAL}' to troubleshoot the problem.\n`;
      }

      message += e.message;
      log.errorAndThrow(message);
    }
  }

  sessionId() {
    if (this.state !== Chromedriver.STATE_ONLINE) {
      return null;
    }

    return this.jwproxy.sessionId;
  }

  async restart() {
    log.info('Restarting chromedriver');

    if (this.state !== Chromedriver.STATE_ONLINE) {
      throw new Error("Can't restart when we're not online");
    }

    this.changeState(Chromedriver.STATE_RESTARTING);
    await this.stop(false);
    await this.start(this.capabilities, false);
  }

  async waitForOnline() {
    let chromedriverStopped = false;
    await (0, _asyncbox.retryInterval)(20, 200, async () => {
      if (this.state === Chromedriver.STATE_STOPPED) {
        chromedriverStopped = true;
        return;
      }

      await this.getStatus();
    });

    if (chromedriverStopped) {
      throw new Error('ChromeDriver crashed during startup.');
    }
  }

  async getStatus() {
    return await this.jwproxy.command('/status', 'GET');
  }

  async startSession() {
    await (0, _asyncbox.retryInterval)(4, 200, async () => {
      try {
        const res = await this.jwproxy.command('/session', 'POST', {
          desiredCapabilities: this.capabilities
        });

        if (res.status) {
          throw new Error(res.value.message);
        }
      } catch (err) {
        log.errorAndThrow(`Failed to start Chromedriver session: ${err.message}`);
      }
    });
    this.changeState(Chromedriver.STATE_ONLINE);
  }

  async stop(emitStates = true) {
    if (emitStates) {
      this.changeState(Chromedriver.STATE_STOPPING);
    }

    try {
      await this.jwproxy.command('', 'DELETE');
      await this.proc.stop('SIGTERM', 20000);

      if (emitStates) {
        this.changeState(Chromedriver.STATE_STOPPED);
      }
    } catch (e) {
      log.error(e);
    }
  }

  changeState(state) {
    this.state = state;
    log.debug(`Changed state to '${state}'`);
    this.emit(Chromedriver.EVENT_CHANGED, {
      state
    });
  }

  async sendCommand(url, method, body) {
    return await this.jwproxy.command(url, method, body);
  }

  async proxyReq(req, res) {
    return await this.jwproxy.proxyReqRes(req, res);
  }

  async killAll() {
    let cmd = _appiumSupport.system.isWindows() ? `wmic process where "commandline like '%chromedriver.exe%--port=${this.proxyPort}%'" delete` : `pkill -15 -f "${this.chromedriver}.*--port=${this.proxyPort}"`;
    log.debug(`Killing any old chromedrivers, running: ${cmd}`);

    try {
      await _bluebird.default.promisify(_child_process.default.exec)(cmd);
      log.debug('Successfully cleaned up old chromedrivers');
    } catch (err) {
      log.warn('No old chromedrivers seem to exist');
    }

    if (this.adb) {
      log.debug(`Cleaning any old adb forwarded port socket connections`);

      try {
        for (let conn of await this.adb.getForwardList()) {
          if (conn.indexOf('webview_devtools') !== -1) {
            let params = conn.split(/\s+/);

            if (params.length > 1) {
              await this.adb.removePortForward(params[1].replace(/[\D]*/, ''));
            }
          }
        }
      } catch (err) {
        log.warn(`Unable to clean forwarded ports. Error: '${err.message}'. Continuing.`);
      }
    }
  }

  async hasWorkingWebview() {
    try {
      await this.jwproxy.command('/url', 'GET');
      return true;
    } catch (e) {
      return false;
    }
  }

}

exports.Chromedriver = Chromedriver;
Chromedriver.EVENT_ERROR = 'chromedriver_error';
Chromedriver.EVENT_CHANGED = 'stateChanged';
Chromedriver.STATE_STOPPED = 'stopped';
Chromedriver.STATE_STARTING = 'starting';
Chromedriver.STATE_ONLINE = 'online';
Chromedriver.STATE_STOPPING = 'stopping';
Chromedriver.STATE_RESTARTING = 'restarting';
var _default = Chromedriver;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jaHJvbWVkcml2ZXIuanMiXSwibmFtZXMiOlsibG9nIiwibG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiTkVXX0NEX1ZFUlNJT05fRk9STUFUX01BSk9SX1ZFUlNJT04iLCJERUZBVUxUX0hPU1QiLCJERUZBVUxUX1BPUlQiLCJDSFJPTUVEUklWRVJfQ0hST01FX01BUFBJTkciLCJDSFJPTUVfQlVORExFX0lEIiwiV0VCVklFV19CVU5ETEVfSURTIiwiQ0hST01FRFJJVkVSX1RVVE9SSUFMIiwiQ0RfVkVSIiwicHJvY2VzcyIsImVudiIsIm5wbV9jb25maWdfY2hyb21lZHJpdmVyX3ZlcnNpb24iLCJDSFJPTUVEUklWRVJfVkVSU0lPTiIsImdldE1vc3RSZWNlbnRDaHJvbWVkcml2ZXIiLCJDRF9WRVJTSU9OX1RJTUVPVVQiLCJtYXBwaW5nIiwiXyIsImlzRW1wdHkiLCJFcnJvciIsImxhc3QiLCJrZXlzIiwic29ydCIsImNvbXBhcmVWZXJzaW9ucyIsIkNocm9tZWRyaXZlciIsImV2ZW50cyIsIkV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwiYXJncyIsImhvc3QiLCJwb3J0IiwidXNlU3lzdGVtRXhlY3V0YWJsZSIsImV4ZWN1dGFibGUiLCJleGVjdXRhYmxlRGlyIiwiYnVuZGxlSWQiLCJtYXBwaW5nUGF0aCIsImNtZEFyZ3MiLCJhZGIiLCJ2ZXJib3NlIiwibG9nUGF0aCIsImRpc2FibGVCdWlsZENoZWNrIiwiaXNBdXRvZG93bmxvYWRFbmFibGVkIiwicHJveHlIb3N0IiwicHJveHlQb3J0IiwicHJvYyIsImNocm9tZWRyaXZlciIsImV4ZWN1dGFibGVWZXJpZmllZCIsInN0YXRlIiwiU1RBVEVfU1RPUFBFRCIsImp3cHJveHkiLCJKV1Byb3h5Iiwic2VydmVyIiwic3RvcmFnZUNsaWVudCIsIkNocm9tZWRyaXZlclN0b3JhZ2VDbGllbnQiLCJjaHJvbWVkcml2ZXJEaXIiLCJnZXRNYXBwaW5nIiwiZGVidWciLCJmcyIsImV4aXN0cyIsIndhcm4iLCJKU09OIiwicGFyc2UiLCJyZWFkRmlsZSIsImVyciIsImVycm9yIiwibWVzc2FnZSIsImNkVmVyc2lvbiIsImNocm9tZVZlcnNpb24iLCJ0b1BhaXJzIiwic2VtdmVyIiwiY29lcmNlIiwiZ2V0Q2hyb21lZHJpdmVycyIsImV4ZWN1dGFibGVzIiwiZ2xvYiIsImxlbmd0aCIsImNkcyIsIm1hcENocm9tZWRyaXZlciIsImxvZ0Vycm9yIiwic3Rkb3V0Iiwic3RkZXJyIiwiZXJyTXNnIiwicGF0aCIsImJhc2VuYW1lIiwidGltZW91dCIsImluY2x1ZGVzIiwibWF0Y2giLCJleGVjIiwidmVyc2lvbiIsImNvZXJjZWRWZXJzaW9uIiwibWFqb3IiLCJtaW5vciIsIm1pbkNocm9tZVZlcnNpb24iLCJmaWx0ZXIiLCJjZCIsImEiLCJiIiwiZXJyb3JBbmRUaHJvdyIsImdldENocm9tZVZlcnNpb24iLCJnZXRBcGlMZXZlbCIsImdldENvbXBhdGlibGVDaHJvbWVkcml2ZXIiLCJkaWRTdG9yYWdlU3luYyIsInN5bmNDaHJvbWVkcml2ZXJzIiwicmV0cmlldmVkTWFwcGluZyIsInJldHJpZXZlTWFwcGluZyIsInN0cmluZ2lmeSIsImRyaXZlcktleXMiLCJzeW5jRHJpdmVycyIsIm1pbkJyb3dzZXJWZXJzaW9uIiwic3luY2hyb25pemVkRHJpdmVyc01hcHBpbmciLCJyZWR1Y2UiLCJhY2MiLCJ4IiwiT2JqZWN0IiwiYXNzaWduIiwic2hvdWxkVXBkYXRlR2xvYmFsTWFwcGluZyIsIndyaXRlRmlsZSIsImUiLCJhdXRvZG93bmxvYWRNc2ciLCJndCIsInZhbHVlcyIsInN0YWNrIiwid29ya2luZ0NkcyIsInZlcnNpb25PYmoiLCJiaW5QYXRoIiwiaW5pdENocm9tZWRyaXZlclBhdGgiLCJpbmZvIiwic3RhcnQiLCJjYXBzIiwiZW1pdFN0YXJ0aW5nU3RhdGUiLCJjYXBhYmlsaXRpZXMiLCJjbG9uZURlZXAiLCJsb2dnaW5nUHJlZnMiLCJicm93c2VyIiwiY2hhbmdlU3RhdGUiLCJTVEFURV9TVEFSVElORyIsImFkYlBvcnQiLCJjb25jYXQiLCJzdGFydERldGVjdG9yIiwiaW5kZXhPZiIsInByb2Nlc3NJc0FsaXZlIiwid2Vidmlld1ZlcnNpb24iLCJraWxsQWxsIiwiU3ViUHJvY2VzcyIsIm9uIiwib3V0IiwibGluZSIsInRyaW0iLCJzcGxpdCIsImNvZGUiLCJzaWduYWwiLCJTVEFURV9TVE9QUElORyIsIlNUQVRFX1JFU1RBUlRJTkciLCJtc2ciLCJqb2luIiwid2FpdEZvck9ubGluZSIsInN0YXJ0U2Vzc2lvbiIsImVtaXQiLCJFVkVOVF9FUlJPUiIsInN0b3AiLCJzZXNzaW9uSWQiLCJTVEFURV9PTkxJTkUiLCJyZXN0YXJ0IiwiY2hyb21lZHJpdmVyU3RvcHBlZCIsImdldFN0YXR1cyIsImNvbW1hbmQiLCJyZXMiLCJkZXNpcmVkQ2FwYWJpbGl0aWVzIiwic3RhdHVzIiwidmFsdWUiLCJlbWl0U3RhdGVzIiwiRVZFTlRfQ0hBTkdFRCIsInNlbmRDb21tYW5kIiwidXJsIiwibWV0aG9kIiwiYm9keSIsInByb3h5UmVxIiwicmVxIiwicHJveHlSZXFSZXMiLCJjbWQiLCJzeXN0ZW0iLCJpc1dpbmRvd3MiLCJCIiwicHJvbWlzaWZ5IiwiY3AiLCJjb25uIiwiZ2V0Rm9yd2FyZExpc3QiLCJwYXJhbXMiLCJyZW1vdmVQb3J0Rm9yd2FyZCIsInJlcGxhY2UiLCJoYXNXb3JraW5nV2VidmlldyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0EsTUFBTUEsR0FBRyxHQUFHQyxzQkFBT0MsU0FBUCxDQUFpQixjQUFqQixDQUFaOztBQUVBLE1BQU1DLG1DQUFtQyxHQUFHLEVBQTVDO0FBQ0EsTUFBTUMsWUFBWSxHQUFHLFdBQXJCO0FBQ0EsTUFBTUMsWUFBWSxHQUFHLElBQXJCO0FBQ0EsTUFBTUMsMkJBQTJCLEdBQUc7QUFFbEMsa0JBQWdCLGNBRmtCO0FBR2xDLGlC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XG5pbXBvcnQgeyBKV1Byb3h5IH0gZnJvbSAnYXBwaXVtLWJhc2UtZHJpdmVyJztcbmltcG9ydCBjcCBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IHN5c3RlbSwgZnMsIGxvZ2dlciB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCB7IHJldHJ5SW50ZXJ2YWwsIGFzeW5jbWFwIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IHsgU3ViUHJvY2VzcywgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBnZXRDaHJvbWVWZXJzaW9uLCBnZXRDaHJvbWVkcml2ZXJEaXIsIGdldENocm9tZWRyaXZlckJpbmFyeVBhdGggfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBjb21wYXJlVmVyc2lvbnMgZnJvbSAnY29tcGFyZS12ZXJzaW9ucyc7XG5pbXBvcnQgQ2hyb21lZHJpdmVyU3RvcmFnZUNsaWVudCBmcm9tICcuL3N0b3JhZ2UtY2xpZW50JztcblxuXG5jb25zdCBsb2cgPSBsb2dnZXIuZ2V0TG9nZ2VyKCdDaHJvbWVkcml2ZXInKTtcblxuY29uc3QgTkVXX0NEX1ZFUlNJT05fRk9STUFUX01BSk9SX1ZFUlNJT04gPSA3MztcbmNvbnN0IERFRkFVTFRfSE9TVCA9ICcxMjcuMC4wLjEnO1xuY29uc3QgREVGQVVMVF9QT1JUID0gOTUxNTtcbmNvbnN0IENIUk9NRURSSVZFUl9DSFJPTUVfTUFQUElORyA9IHtcbiAgLy8gQ2hyb21lZHJpdmVyIHZlcnNpb246IG1pbnVtdW0gQ2hyb21lIHZlcnNpb25cbiAgJzc1LjAuMzc3MC45MCc6ICc3NS4wLjM3NzAuOTAnLFxuICAnNzUuMC4zNzcwLjgnOiAnNzUuMC4zNzcwLjgnLFxuICAnNzQuMC4zNzI5LjYnOiAnNzQuMC4zNzI5JyxcbiAgJzczLjAuMzY4My42OCc6ICc3MC4wLjM1MzgnLFxuICAnMi40Nic6ICc3MS4wLjM1NzgnLFxuICAnMi40NSc6ICc3MC4wLjAnLFxuICAnMi40NCc6ICc2OS4wLjM0OTcnLFxuICAnMi40Myc6ICc2OS4wLjM0OTcnLFxuICAnMi40Mic6ICc2OC4wLjM0NDAnLFxuICAnMi40MSc6ICc2Ny4wLjMzOTYnLFxuICAnMi40MCc6ICc2Ni4wLjMzNTknLFxuICAnMi4zOSc6ICc2Ni4wLjMzNTknLFxuICAnMi4zOCc6ICc2NS4wLjMzMjUnLFxuICAnMi4zNyc6ICc2NC4wLjMyODInLFxuICAnMi4zNic6ICc2My4wLjMyMzknLFxuICAnMi4zNSc6ICc2Mi4wLjMyMDInLFxuICAnMi4zNCc6ICc2MS4wLjMxNjMnLFxuICAnMi4zMyc6ICc2MC4wLjMxMTInLFxuICAnMi4zMic6ICc1OS4wLjMwNzEnLFxuICAnMi4zMSc6ICc1OC4wLjMwMjknLFxuICAnMi4zMCc6ICc1OC4wLjMwMjknLFxuICAnMi4yOSc6ICc1Ny4wLjI5ODcnLFxuICAnMi4yOCc6ICc1NS4wLjI4ODMnLFxuICAnMi4yNyc6ICc1NC4wLjI4NDAnLFxuICAnMi4yNic6ICc1My4wLjI3ODUnLFxuICAnMi4yNSc6ICc1My4wLjI3ODUnLFxuICAnMi4yNCc6ICc1Mi4wLjI3NDMnLFxuICAnMi4yMyc6ICc1MS4wLjI3MDQnLFxuICAnMi4yMic6ICc0OS4wLjI2MjMnLFxuICAnMi4yMSc6ICc0Ni4wLjI0OTAnLFxuICAnMi4yMCc6ICc0My4wLjIzNTcnLFxuICAnMi4xOSc6ICc0My4wLjIzNTcnLFxuICAnMi4xOCc6ICc0My4wLjIzNTcnLFxuICAnMi4xNyc6ICc0Mi4wLjIzMTEnLFxuICAnMi4xNic6ICc0Mi4wLjIzMTEnLFxuICAnMi4xNSc6ICc0MC4wLjIyMTQnLFxuICAnMi4xNCc6ICczOS4wLjIxNzEnLFxuICAnMi4xMyc6ICczOC4wLjIxMjUnLFxuICAnMi4xMic6ICczNi4wLjE5ODUnLFxuICAnMi4xMSc6ICczNi4wLjE5ODUnLFxuICAnMi4xMCc6ICczMy4wLjE3NTEnLFxuICAnMi45JzogJzMxLjAuMTY1MCcsXG4gICcyLjgnOiAnMzAuMC4xNTczJyxcbiAgJzIuNyc6ICczMC4wLjE1NzMnLFxuICAnMi42JzogJzI5LjAuMTU0NScsXG4gICcyLjUnOiAnMjkuMC4xNTQ1JyxcbiAgJzIuNCc6ICcyOS4wLjE1NDUnLFxuICAnMi4zJzogJzI4LjAuMTUwMCcsXG4gICcyLjInOiAnMjcuMC4xNDUzJyxcbiAgJzIuMSc6ICcyNy4wLjE0NTMnLFxuICAnMi4wJzogJzI3LjAuMTQ1MycsXG59O1xuY29uc3QgQ0hST01FX0JVTkRMRV9JRCA9ICdjb20uYW5kcm9pZC5jaHJvbWUnO1xuY29uc3QgV0VCVklFV19CVU5ETEVfSURTID0gW1xuICAnY29tLmdvb2dsZS5hbmRyb2lkLndlYnZpZXcnLFxuICAnY29tLmFuZHJvaWQud2VidmlldycsXG5dO1xuY29uc3QgQ0hST01FRFJJVkVSX1RVVE9SSUFMID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vYXBwaXVtL2Jsb2IvbWFzdGVyL2RvY3MvZW4vd3JpdGluZy1ydW5uaW5nLWFwcGl1bS93ZWIvY2hyb21lZHJpdmVyLm1kJztcblxuY29uc3QgQ0RfVkVSID0gcHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19jaHJvbWVkcml2ZXJfdmVyc2lvbiB8fFxuICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuQ0hST01FRFJJVkVSX1ZFUlNJT04gfHxcbiAgICAgICAgICAgICAgIGdldE1vc3RSZWNlbnRDaHJvbWVkcml2ZXIoKTtcblxuY29uc3QgQ0RfVkVSU0lPTl9USU1FT1VUID0gNTAwMDtcblxuZnVuY3Rpb24gZ2V0TW9zdFJlY2VudENocm9tZWRyaXZlciAobWFwcGluZyA9IENIUk9NRURSSVZFUl9DSFJPTUVfTUFQUElORykge1xuICBpZiAoXy5pc0VtcHR5KG1hcHBpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IG1vc3QgcmVjZW50IENocm9tZWRyaXZlciBmcm9tIGVtcHR5IG1hcHBpbmcnKTtcbiAgfVxuICByZXR1cm4gXy5sYXN0KF8ua2V5cyhtYXBwaW5nKS5zb3J0KGNvbXBhcmVWZXJzaW9ucykpO1xufVxuXG5jbGFzcyBDaHJvbWVkcml2ZXIgZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKGFyZ3MgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb25zdCB7XG4gICAgICBob3N0ID0gREVGQVVMVF9IT1NULFxuICAgICAgcG9ydCA9IERFRkFVTFRfUE9SVCxcbiAgICAgIHVzZVN5c3RlbUV4ZWN1dGFibGUgPSBmYWxzZSxcbiAgICAgIGV4ZWN1dGFibGUsXG4gICAgICBleGVjdXRhYmxlRGlyID0gZ2V0Q2hyb21lZHJpdmVyRGlyKCksXG4gICAgICBidW5kbGVJZCxcbiAgICAgIG1hcHBpbmdQYXRoLFxuICAgICAgY21kQXJncyxcbiAgICAgIGFkYixcbiAgICAgIHZlcmJvc2UsXG4gICAgICBsb2dQYXRoLFxuICAgICAgZGlzYWJsZUJ1aWxkQ2hlY2ssXG4gICAgICBpc0F1dG9kb3dubG9hZEVuYWJsZWQgPSBmYWxzZSxcbiAgICB9ID0gYXJncztcblxuICAgIHRoaXMucHJveHlIb3N0ID0gaG9zdDtcbiAgICB0aGlzLnByb3h5UG9ydCA9IHBvcnQ7XG4gICAgdGhpcy5hZGIgPSBhZGI7XG4gICAgdGhpcy5jbWRBcmdzID0gY21kQXJncztcbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICAgIHRoaXMudXNlU3lzdGVtRXhlY3V0YWJsZSA9IHVzZVN5c3RlbUV4ZWN1dGFibGU7XG4gICAgdGhpcy5jaHJvbWVkcml2ZXIgPSBleGVjdXRhYmxlO1xuICAgIHRoaXMuZXhlY3V0YWJsZURpciA9IGV4ZWN1dGFibGVEaXI7XG4gICAgdGhpcy5tYXBwaW5nUGF0aCA9IG1hcHBpbmdQYXRoO1xuICAgIHRoaXMuYnVuZGxlSWQgPSBidW5kbGVJZDtcbiAgICB0aGlzLmV4ZWN1dGFibGVWZXJpZmllZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUgPSBDaHJvbWVkcml2ZXIuU1RBVEVfU1RPUFBFRDtcbiAgICB0aGlzLmp3cHJveHkgPSBuZXcgSldQcm94eSh7c2VydmVyOiB0aGlzLnByb3h5SG9zdCwgcG9ydDogdGhpcy5wcm94eVBvcnR9KTtcbiAgICB0aGlzLnZlcmJvc2UgPSB2ZXJib3NlO1xuICAgIHRoaXMubG9nUGF0aCA9IGxvZ1BhdGg7XG4gICAgdGhpcy5kaXNhYmxlQnVpbGRDaGVjayA9ICEhZGlzYWJsZUJ1aWxkQ2hlY2s7XG4gICAgdGhpcy5zdG9yYWdlQ2xpZW50ID0gaXNBdXRvZG93bmxvYWRFbmFibGVkXG4gICAgICA/IG5ldyBDaHJvbWVkcml2ZXJTdG9yYWdlQ2xpZW50KHsgY2hyb21lZHJpdmVyRGlyOiB0aGlzLmV4ZWN1dGFibGVEaXIgfSlcbiAgICAgIDogbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGdldE1hcHBpbmcgKCkge1xuICAgIGxldCBtYXBwaW5nID0gQ0hST01FRFJJVkVSX0NIUk9NRV9NQVBQSU5HO1xuICAgIGlmICh0aGlzLm1hcHBpbmdQYXRoKSB7XG4gICAgICBsb2cuZGVidWcoYEF0dGVtcHRpbmcgdG8gdXNlIENocm9tZWRyaXZlci1DaHJvbWUgbWFwcGluZyBmcm9tICcke3RoaXMubWFwcGluZ1BhdGh9J2ApO1xuICAgICAgaWYgKCFhd2FpdCBmcy5leGlzdHModGhpcy5tYXBwaW5nUGF0aCkpIHtcbiAgICAgICAgbG9nLndhcm4oYE5vIGZpbGUgZm91bmQgYXQgJyR7dGhpcy5tYXBwaW5nUGF0aH0nLiBVc2luZyBkZWZhdWx0IG1hcHBpbmdgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWFwcGluZyA9IEpTT04ucGFyc2UoYXdhaXQgZnMucmVhZEZpbGUodGhpcy5tYXBwaW5nUGF0aCkpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBsb2cuZXJyb3IoYEVycm9yIHBhcnNpbmcgbWFwcGluZyBmcm9tICcke3RoaXMubWFwcGluZ1BhdGh9JzogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICBsb2cud2FybignVXNpbmcgZGVmYXVsdCBtYXBwaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWVzIGZvciBtaW5pbXVtIGNocm9tZSB2ZXJzaW9uIGFyZSBzZW12ZXIgY29tcGxpYW50XG4gICAgZm9yIChjb25zdCBbY2RWZXJzaW9uLCBjaHJvbWVWZXJzaW9uXSBvZiBfLnRvUGFpcnMobWFwcGluZykpIHtcbiAgICAgIG1hcHBpbmdbY2RWZXJzaW9uXSA9IHNlbXZlci5jb2VyY2UoY2hyb21lVmVyc2lvbik7XG4gICAgfVxuICAgIHJldHVybiBtYXBwaW5nO1xuICB9XG5cbiAgYXN5bmMgZ2V0Q2hyb21lZHJpdmVycyAobWFwcGluZykge1xuICAgIC8vIGdvIHRocm91Z2ggdGhlIHZlcnNpb25zIGF2YWlsYWJsZVxuICAgIGNvbnN0IGV4ZWN1dGFibGVzID0gYXdhaXQgZnMuZ2xvYihgJHt0aGlzLmV4ZWN1dGFibGVEaXJ9LypgKTtcbiAgICBsb2cuZGVidWcoYEZvdW5kICR7ZXhlY3V0YWJsZXMubGVuZ3RofSBleGVjdXRhYmxlJHtleGVjdXRhYmxlcy5sZW5ndGggPT09IDEgPyAnJyA6ICdzJ30gYCArXG4gICAgICBgaW4gJyR7dGhpcy5leGVjdXRhYmxlRGlyfSdgKTtcbiAgICBjb25zdCBjZHMgPSAoYXdhaXQgYXN5bmNtYXAoZXhlY3V0YWJsZXMsIGFzeW5jIGZ1bmN0aW9uIG1hcENocm9tZWRyaXZlciAoZXhlY3V0YWJsZSkge1xuICAgICAgY29uc3QgbG9nRXJyb3IgPSAoe21lc3NhZ2UsIHN0ZG91dCA9IG51bGwsIHN0ZGVyciA9IG51bGx9KSA9PiB7XG4gICAgICAgIGxldCBlcnJNc2cgPSBgQ2Fubm90IHJldHJpZXZlIHZlcnNpb24gbnVtYmVyIGZyb20gJyR7cGF0aC5iYXNlbmFtZShleGVjdXRhYmxlKX0nIENocm9tZWRyaXZlciBiaW5hcnkuIGAgK1xuICAgICAgICAgIGBNYWtlIHN1cmUgaXQgcmV0dXJucyBhIHZhbGlkIHZlcnNpb24gc3RyaW5nIGluIHJlc3BvbnNlIHRvICctLXZlcnNpb24nIGNvbW1hbmQgbGluZSBhcmd1bWVudC4gJHttZXNzYWdlfWA7XG4gICAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgICBlcnJNc2cgKz0gYFxcblN0ZG91dDogJHtzdGRvdXR9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RkZXJyKSB7XG4gICAgICAgICAgZXJyTXNnICs9IGBcXG5TdGRlcnI6ICR7c3RkZXJyfWA7XG4gICAgICAgIH1cbiAgICAgICAgbG9nLndhcm4oZXJyTXNnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgICBsZXQgc3Rkb3V0O1xuICAgICAgbGV0IHN0ZGVycjtcbiAgICAgIHRyeSB7XG4gICAgICAgICh7c3Rkb3V0LCBzdGRlcnJ9ID0gYXdhaXQgZXhlYyhleGVjdXRhYmxlLCBbJy0tdmVyc2lvbiddLCB7XG4gICAgICAgICAgdGltZW91dDogQ0RfVkVSU0lPTl9USU1FT1VULFxuICAgICAgICB9KSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCEoZXJyLm1lc3NhZ2UgfHwgJycpLmluY2x1ZGVzKCd0aW1lZCBvdXQnKSAmJiAhKGVyci5zdGRvdXQgfHwgJycpLmluY2x1ZGVzKCdTdGFydGluZyBDaHJvbWVEcml2ZXInKSkge1xuICAgICAgICAgIHJldHVybiBsb2dFcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyBoYXMgdGltZWQgb3V0LCBpdCBoYXMgYWN0dWFsbHkgc3RhcnRlZCBDaHJvbWVkcml2ZXIsXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2UgdGhlcmUgd2lsbCBhbHNvIGJlIHRoZSB2ZXJzaW9uIHN0cmluZyBpbiB0aGUgb3V0cHV0XG4gICAgICAgIHN0ZG91dCA9IGVyci5zdGRvdXQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hdGNoID0gL0Nocm9tZURyaXZlclxccytcXCg/dj8oW1xcZC5dKylcXCk/L2kuZXhlYyhzdGRvdXQpOyAvLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yL3pwajV3QS8xXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBsb2dFcnJvcih7bWVzc2FnZTogJ0Nhbm5vdCBwYXJzZSB0aGUgdmVyc2lvbiBzdHJpbmcnLCBzdGRvdXQsIHN0ZGVycn0pO1xuICAgICAgfVxuICAgICAgbGV0IHZlcnNpb24gPSBtYXRjaFsxXTtcbiAgICAgIGNvbnN0IGNvZXJjZWRWZXJzaW9uID0gc2VtdmVyLmNvZXJjZSh2ZXJzaW9uLCB0cnVlKTtcbiAgICAgIGlmIChjb2VyY2VkVmVyc2lvbikge1xuICAgICAgICAvLyBiZWZvcmUgMjAxOS0wMy0wNiB2ZXJzaW9ucyB3ZXJlIG9mIHRoZSBmb3JtIG1ham9yLm1pbm9yXG4gICAgICAgIGlmIChjb2VyY2VkVmVyc2lvbi5tYWpvciA8IE5FV19DRF9WRVJTSU9OX0ZPUk1BVF9NQUpPUl9WRVJTSU9OKSB7XG4gICAgICAgICAgdmVyc2lvbiA9IGAke2NvZXJjZWRWZXJzaW9uLm1ham9yfS4ke2NvZXJjZWRWZXJzaW9uLm1pbm9yfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4ZWN1dGFibGUsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIG1pbkNocm9tZVZlcnNpb246IG1hcHBpbmdbdmVyc2lvbl0sXG4gICAgICB9O1xuICAgIH0pKVxuICAgICAgLmZpbHRlcigoY2QpID0+ICEhY2QpXG4gICAgICAuc29ydCgoYSwgYikgPT4gY29tcGFyZVZlcnNpb25zKGIudmVyc2lvbiwgYS52ZXJzaW9uKSk7XG4gICAgaWYgKF8uaXNFbXB0eShjZHMpKSB7XG4gICAgICBsb2cuZXJyb3JBbmRUaHJvdyhgTm8gQ2hyb21lZHJpdmVycyBmb3VuZCBpbiAnJHt0aGlzLmV4ZWN1dGFibGVEaXJ9J2ApO1xuICAgIH1cbiAgICBsb2cuZGVidWcoYFRoZSBmb2xsb3dpbmcgQ2hyb21lZHJpdmVyIGV4ZWN1dGFibGVzIHdlcmUgZm91bmQ6YCk7XG4gICAgZm9yIChjb25zdCBjZCBvZiBjZHMpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgICAgICcke2NkLmV4ZWN1dGFibGV9JyAodmVyc2lvbiAnJHtjZC52ZXJzaW9ufScsIG1pbmltdW0gQ2hyb21lIHZlcnNpb24gJyR7Y2QubWluQ2hyb21lVmVyc2lvbiA/IGNkLm1pbkNocm9tZVZlcnNpb24gOiAnVW5rbm93bid9JylgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNkcztcbiAgfVxuXG4gIGFzeW5jIGdldENocm9tZVZlcnNpb24gKCkge1xuICAgIGxldCBjaHJvbWVWZXJzaW9uO1xuXG4gICAgLy8gb24gQW5kcm9pZCA3KyB3ZWJ2aWV3cyBhcmUgYmFja2VkIGJ5IHRoZSBtYWluIENocm9tZSwgbm90IHRoZSBzeXN0ZW0gd2Vidmlld1xuICAgIGlmICh0aGlzLmFkYiAmJiBhd2FpdCB0aGlzLmFkYi5nZXRBcGlMZXZlbCgpID49IDI0KSB7XG4gICAgICB0aGlzLmJ1bmRsZUlkID0gQ0hST01FX0JVTkRMRV9JRDtcbiAgICB9XG5cbiAgICAvLyB0cnkgb3V0IHdlYnZpZXdzIHdoZW4gbm8gYnVuZGxlIGlkIGlzIHNlbnQgaW5cbiAgICBpZiAoIXRoaXMuYnVuZGxlSWQpIHtcbiAgICAgIC8vIGRlZmF1bHQgdG8gdGhlIGdlbmVyaWMgQ2hyb21lIGJ1bmRsZVxuICAgICAgdGhpcy5idW5kbGVJZCA9IENIUk9NRV9CVU5ETEVfSUQ7XG5cbiAgICAgIC8vIHdlIGhhdmUgYSB3ZWJ2aWV3IG9mIHNvbWUgc29ydCwgc28gdHJ5IHRvIGZpbmQgdGhlIGJ1bmRsZSB2ZXJzaW9uXG4gICAgICBmb3IgKGNvbnN0IGJ1bmRsZUlkIG9mIFdFQlZJRVdfQlVORExFX0lEUykge1xuICAgICAgICBjaHJvbWVWZXJzaW9uID0gYXdhaXQgZ2V0Q2hyb21lVmVyc2lvbih0aGlzLmFkYiwgYnVuZGxlSWQpO1xuICAgICAgICBpZiAoY2hyb21lVmVyc2lvbikge1xuICAgICAgICAgIHRoaXMuYnVuZGxlSWQgPSBidW5kbGVJZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGRvIG5vdCBoYXZlIGEgY2hyb21lIHZlcnNpb24sIGl0IG11c3Qgbm90IGJlIGEgd2Vidmlld1xuICAgIGlmICghY2hyb21lVmVyc2lvbikge1xuICAgICAgY2hyb21lVmVyc2lvbiA9IGF3YWl0IGdldENocm9tZVZlcnNpb24odGhpcy5hZGIsIHRoaXMuYnVuZGxlSWQpO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSBpdCBpcyBzZW12ZXIsIHNvIGxhdGVyIGNoZWNrcyB3b24ndCBmYWlsXG4gICAgcmV0dXJuIGNocm9tZVZlcnNpb24gPyBzZW12ZXIuY29lcmNlKGNocm9tZVZlcnNpb24pIDogbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGdldENvbXBhdGlibGVDaHJvbWVkcml2ZXIgKCkge1xuICAgIGlmICghdGhpcy5hZGIpIHtcbiAgICAgIHJldHVybiBhd2FpdCBnZXRDaHJvbWVkcml2ZXJCaW5hcnlQYXRoKCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWFwcGluZyA9IGF3YWl0IHRoaXMuZ2V0TWFwcGluZygpO1xuICAgIGxldCBkaWRTdG9yYWdlU3luYyA9IGZhbHNlO1xuICAgIGNvbnN0IHN5bmNDaHJvbWVkcml2ZXJzID0gYXN5bmMgKGNocm9tZVZlcnNpb24pID0+IHtcbiAgICAgIGRpZFN0b3JhZ2VTeW5jID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHJldHJpZXZlZE1hcHBpbmcgPSBhd2FpdCB0aGlzLnN0b3JhZ2VDbGllbnQucmV0cmlldmVNYXBwaW5nKCk7XG4gICAgICBsb2cuZGVidWcoJ0dvdCBjaHJvbWVkcml2ZXJzIG1hcHBpbmcgZnJvbSB0aGUgc3RvcmFnZTogJyArXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHJldHJpZXZlZE1hcHBpbmcsIG51bGwsIDIpKTtcbiAgICAgIGNvbnN0IGRyaXZlcktleXMgPSBhd2FpdCB0aGlzLnN0b3JhZ2VDbGllbnQuc3luY0RyaXZlcnMoe1xuICAgICAgICBtaW5Ccm93c2VyVmVyc2lvbjogY2hyb21lVmVyc2lvbi5tYWpvcixcbiAgICAgIH0pO1xuICAgICAgaWYgKF8uaXNFbXB0eShkcml2ZXJLZXlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzeW5jaHJvbml6ZWREcml2ZXJzTWFwcGluZyA9IGRyaXZlcktleXMucmVkdWNlKChhY2MsIHgpID0+IHtcbiAgICAgICAgY29uc3Qge3ZlcnNpb24sIG1pbkJyb3dzZXJWZXJzaW9ufSA9IHJldHJpZXZlZE1hcHBpbmdbeF07XG4gICAgICAgIGFjY1t2ZXJzaW9uXSA9IG1pbkJyb3dzZXJWZXJzaW9uO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgICAgT2JqZWN0LmFzc2lnbihtYXBwaW5nLCBzeW5jaHJvbml6ZWREcml2ZXJzTWFwcGluZyk7XG4gICAgICBsZXQgc2hvdWxkVXBkYXRlR2xvYmFsTWFwcGluZyA9IHRydWU7XG4gICAgICBpZiAoYXdhaXQgZnMuZXhpc3RzKHRoaXMubWFwcGluZ1BhdGgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHRoaXMubWFwcGluZ1BhdGgsIEpTT04uc3RyaW5naWZ5KG1hcHBpbmcsIG51bGwsIDIpLCAndXRmOCcpO1xuICAgICAgICAgIHNob3VsZFVwZGF0ZUdsb2JhbE1hcHBpbmcgPSBmYWxzZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZy53YXJuKGBDYW5ub3Qgc3RvcmUgdGhlIHVwZGF0ZWQgY2hyb21lZHJpdmVycyBtYXBwaW5nIGludG8gJyR7dGhpcy5tYXBwaW5nUGF0aH0nLiBgICtcbiAgICAgICAgICAgIGBUaGlzIG1heSByZWR1Y2UgdGhlIHBlcmZvcm1hbmNlIG9mIGZ1cnRoZXIgZXhlY3V0aW9ucy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlR2xvYmFsTWFwcGluZykge1xuICAgICAgICBPYmplY3QuYXNzaWduKENIUk9NRURSSVZFUl9DSFJPTUVfTUFQUElORywgbWFwcGluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZG8ge1xuICAgICAgY29uc3QgY2RzID0gYXdhaXQgdGhpcy5nZXRDaHJvbWVkcml2ZXJzKG1hcHBpbmcpO1xuXG4gICAgICBpZiAodGhpcy5kaXNhYmxlQnVpbGRDaGVjaykge1xuICAgICAgICBjb25zdCB7dmVyc2lvbiwgZXhlY3V0YWJsZX0gPSBjZHNbMF07XG4gICAgICAgIGxvZy53YXJuKGBDaHJvbWUgYnVpbGQgY2hlY2sgZGlzYWJsZWQuIFVzaW5nIG1vc3QgcmVjZW50IENocm9tZWRyaXZlciB2ZXJzaW9uICgke3ZlcnNpb259LCBhdCAnJHtleGVjdXRhYmxlfScpYCk7XG4gICAgICAgIGxvZy53YXJuKGBJZiB0aGlzIGlzIHdyb25nLCBzZXQgJ2Nocm9tZWRyaXZlckRpc2FibGVCdWlsZENoZWNrJyBjYXBhYmlsaXR5IHRvICdmYWxzZSdgKTtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGFibGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNocm9tZVZlcnNpb24gPSBhd2FpdCB0aGlzLmdldENocm9tZVZlcnNpb24oKTtcbiAgICAgIGlmICghY2hyb21lVmVyc2lvbikge1xuICAgICAgICAvLyB1bmFibGUgdG8gZ2V0IHRoZSBjaHJvbWUgdmVyc2lvblxuICAgICAgICBjb25zdCB7dmVyc2lvbiwgZXhlY3V0YWJsZX0gPSBjZHNbMF07XG4gICAgICAgIGxvZy53YXJuKGBVbmFibGUgdG8gZGlzY292ZXIgQ2hyb21lIHZlcnNpb24uIFVzaW5nIENocm9tZWRyaXZlciAke3ZlcnNpb259IGF0ICcke2V4ZWN1dGFibGV9J2ApO1xuICAgICAgICByZXR1cm4gZXhlY3V0YWJsZTtcbiAgICAgIH1cblxuICAgICAgbG9nLmRlYnVnKGBGb3VuZCBDaHJvbWUgYnVuZGxlICcke3RoaXMuYnVuZGxlSWR9JyB2ZXJzaW9uICcke2Nocm9tZVZlcnNpb259J2ApO1xuXG4gICAgICBjb25zdCBhdXRvZG93bmxvYWRNc2cgPSB0aGlzLnN0b3JhZ2VDbGllbnQgJiYgZGlkU3RvcmFnZVN5bmNcbiAgICAgICAgPyAnJ1xuICAgICAgICA6ICcuIFlvdSBjb3VsZCBhbHNvIHRyeSB0byBlbmFibGUgYXV0b21hdGVkIGNocm9tZWRyaXZlcnMgZG93bmxvYWQgc2VydmVyIGZlYXR1cmUnO1xuICAgICAgaWYgKHNlbXZlci5ndChjaHJvbWVWZXJzaW9uLCBfLnZhbHVlcyhtYXBwaW5nKVswXSkgJiYgY2RzWzBdICYmICFjZHNbMF0ubWluQ2hyb21lVmVyc2lvbikge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlQ2xpZW50ICYmICFkaWRTdG9yYWdlU3luYykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgc3luY0Nocm9tZWRyaXZlcnMoY2hyb21lVmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nLndhcm4oZS5zdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgaXMgYSBjaHJvbWUgYWJvdmUgdGhlIGxhdGVzdCB2ZXJzaW9uIHdlIGtub3cgYWJvdXQsXG4gICAgICAgIC8vIGFuZCB3ZSBoYXZlIGEgY2hyb21lZHJpdmVyIHRoYXQgaXMgYmV5b25kIHdoYXQgd2Uga25vdyxcbiAgICAgICAgLy8gc28gdXNlIHRoZSBtb3N0IHJlY2VudCBjaHJvbWVkcml2ZXIgdGhhdCB3ZSBmb3VuZFxuICAgICAgICBjb25zdCB7dmVyc2lvbiwgZXhlY3V0YWJsZX0gPSBjZHNbMF07XG4gICAgICAgIGxvZy53YXJuKGBObyBrbm93biBDaHJvbWVkcml2ZXIgYXZhaWxhYmxlIHRvIGF1dG9tYXRlIENocm9tZSB2ZXJzaW9uICcke2Nocm9tZVZlcnNpb259Jy5cXG5gICtcbiAgICAgICAgICBgVXNpbmcgQ2hyb21lZHJpdmVyIHZlcnNpb24gJyR7dmVyc2lvbn0nLCB3aGljaCBoYXMgbm90IGJlZW4gdGVzdGVkIHdpdGggQXBwaXVtYCArXG4gICAgICAgICAgYXV0b2Rvd25sb2FkTXNnKTtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGFibGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdvcmtpbmdDZHMgPSBjZHMuZmlsdGVyKChjZCkgPT4ge1xuICAgICAgICBjb25zdCB2ZXJzaW9uT2JqID0gc2VtdmVyLmNvZXJjZShjZC5taW5DaHJvbWVWZXJzaW9uKTtcbiAgICAgICAgcmV0dXJuIHZlcnNpb25PYmogJiYgY2hyb21lVmVyc2lvbi5tYWpvciA9PT0gdmVyc2lvbk9iai5tYWpvcjtcbiAgICAgIH0pO1xuICAgICAgaWYgKF8uaXNFbXB0eSh3b3JraW5nQ2RzKSkge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlQ2xpZW50ICYmICFkaWRTdG9yYWdlU3luYykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgc3luY0Nocm9tZWRyaXZlcnMoY2hyb21lVmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nLndhcm4oZS5zdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvZy5lcnJvckFuZFRocm93KGBObyBDaHJvbWVkcml2ZXIgZm91bmQgdGhhdCBjYW4gYXV0b21hdGUgQ2hyb21lICcke2Nocm9tZVZlcnNpb259Jy4gYCArXG4gICAgICAgICAgYFNlZSAke0NIUk9NRURSSVZFUl9UVVRPUklBTH0gZm9yIG1vcmUgZGV0YWlsc2AgKyBhdXRvZG93bmxvYWRNc2cpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiaW5QYXRoID0gd29ya2luZ0Nkc1swXS5leGVjdXRhYmxlO1xuICAgICAgbG9nLmRlYnVnKGBGb3VuZCAke3dvcmtpbmdDZHMubGVuZ3RofSBDaHJvbWVkcml2ZXIgZXhlY3V0YWJsZSR7d29ya2luZ0Nkcy5sZW5ndGggPT09IDEgPyAnJyA6ICdzJ30gYCArXG4gICAgICAgIGBjYXBhYmxlIG9mIGF1dG9tYXRpbmcgQ2hyb21lICcke2Nocm9tZVZlcnNpb259Jy5cXG5DaG9vc2luZyB0aGUgbW9zdCByZWNlbnQsICcke2JpblBhdGh9Jy5gKTtcbiAgICAgIGxvZy5kZWJ1ZygnSWYgYSBzcGVjaWZpYyB2ZXJzaW9uIGlzIHJlcXVpcmVkLCBzcGVjaWZ5IGl0IHdpdGggdGhlIGBjaHJvbWVkcml2ZXJFeGVjdXRhYmxlYCcgK1xuICAgICAgICAnZGVzaXJlZCBjYXBhYmlsaXR5LicpO1xuICAgICAgcmV0dXJuIGJpblBhdGg7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgIH0gd2hpbGUgKHRydWUpO1xuICB9XG5cbiAgYXN5bmMgaW5pdENocm9tZWRyaXZlclBhdGggKCkge1xuICAgIGlmICh0aGlzLmV4ZWN1dGFibGVWZXJpZmllZCkgcmV0dXJuOyAvL2VzbGludC1kaXNhYmxlLWxpbmUgY3VybHlcblxuICAgIC8vIHRoZSBleGVjdXRhYmxlIG1pZ2h0IGJlIHNldCAoaWYgcGFzc2VkIGluKVxuICAgIC8vIG9yIHdlIG1pZ2h0IHdhbnQgdG8gdXNlIHRoZSBiYXNpYyBvbmUgaW5zdGFsbGVkIHdpdGggdGhpcyBkcml2ZXJcbiAgICAvLyBvciB3ZSB3YW50IHRvIGZpZ3VyZSBvdXQgdGhlIGJlc3Qgb25lXG4gICAgaWYgKCF0aGlzLmNocm9tZWRyaXZlcikge1xuICAgICAgdGhpcy5jaHJvbWVkcml2ZXIgPSB0aGlzLnVzZVN5c3RlbUV4ZWN1dGFibGVcbiAgICAgICAgPyBhd2FpdCBnZXRDaHJvbWVkcml2ZXJCaW5hcnlQYXRoKClcbiAgICAgICAgOiBhd2FpdCB0aGlzLmdldENvbXBhdGlibGVDaHJvbWVkcml2ZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyh0aGlzLmNocm9tZWRyaXZlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJ5aW5nIHRvIHVzZSBhIGNocm9tZWRyaXZlciBiaW5hcnkgYXQgdGhlIHBhdGggYCArXG4gICAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5jaHJvbWVkcml2ZXJ9LCBidXQgaXQgZG9lc24ndCBleGlzdCFgKTtcbiAgICB9XG4gICAgdGhpcy5leGVjdXRhYmxlVmVyaWZpZWQgPSB0cnVlO1xuICAgIGxvZy5pbmZvKGBTZXQgY2hyb21lZHJpdmVyIGJpbmFyeSBhczogJHt0aGlzLmNocm9tZWRyaXZlcn1gKTtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0IChjYXBzLCBlbWl0U3RhcnRpbmdTdGF0ZSA9IHRydWUpIHtcbiAgICB0aGlzLmNhcGFiaWxpdGllcyA9IF8uY2xvbmVEZWVwKGNhcHMpO1xuXG4gICAgLy8gc2V0IHRoZSBsb2dnaW5nIHByZWZlcmVuY2VzIHRvIEFMTCB0aGUgY29uc29sZSBsb2dzXG4gICAgdGhpcy5jYXBhYmlsaXRpZXMubG9nZ2luZ1ByZWZzID0gdGhpcy5jYXBhYmlsaXRpZXMubG9nZ2luZ1ByZWZzIHx8IHt9O1xuICAgIGlmIChfLmlzRW1wdHkodGhpcy5jYXBhYmlsaXRpZXMubG9nZ2luZ1ByZWZzLmJyb3dzZXIpKSB7XG4gICAgICB0aGlzLmNhcGFiaWxpdGllcy5sb2dnaW5nUHJlZnMuYnJvd3NlciA9ICdBTEwnO1xuICAgIH1cblxuICAgIGlmIChlbWl0U3RhcnRpbmdTdGF0ZSkge1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShDaHJvbWVkcml2ZXIuU1RBVEVfU1RBUlRJTkcpO1xuICAgIH1cblxuICAgIGxldCBhcmdzID0gWyctLXVybC1iYXNlPXdkL2h1YicsIGAtLXBvcnQ9JHt0aGlzLnByb3h5UG9ydH1gXTtcbiAgICBpZiAodGhpcy5hZGIgJiYgdGhpcy5hZGIuYWRiUG9ydCkge1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtgLS1hZGItcG9ydD0ke3RoaXMuYWRiLmFkYlBvcnR9YF0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5jbWRBcmdzKSB7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQodGhpcy5jbWRBcmdzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubG9nUGF0aCkge1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtgLS1sb2ctcGF0aD0ke3RoaXMubG9nUGF0aH1gXSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRpc2FibGVCdWlsZENoZWNrKSB7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoWyctLWRpc2FibGUtYnVpbGQtY2hlY2snXSk7XG4gICAgfVxuICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbJy0tdmVyYm9zZSddKTtcbiAgICAvLyB3aGF0IGFyZSB0aGUgcHJvY2VzcyBzdGRvdXQvc3RkZXJyIGNvbmRpdGlvbnMgd2hlcmVpbiB3ZSBrbm93IHRoYXRcbiAgICAvLyB0aGUgcHJvY2VzcyBoYXMgc3RhcnRlZCB0byBvdXIgc2F0aXNmYWN0aW9uP1xuICAgIGNvbnN0IHN0YXJ0RGV0ZWN0b3IgPSAoc3Rkb3V0KSA9PiB7XG4gICAgICByZXR1cm4gc3Rkb3V0LmluZGV4T2YoJ1N0YXJ0aW5nICcpID09PSAwO1xuICAgIH07XG5cbiAgICBsZXQgcHJvY2Vzc0lzQWxpdmUgPSBmYWxzZTtcbiAgICBsZXQgd2Vidmlld1ZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdENocm9tZWRyaXZlclBhdGgoKTtcbiAgICAgIGF3YWl0IHRoaXMua2lsbEFsbCgpO1xuXG4gICAgICAvLyBzZXQgdXAgb3VyIHN1YnByb2Nlc3Mgb2JqZWN0XG4gICAgICB0aGlzLnByb2MgPSBuZXcgU3ViUHJvY2Vzcyh0aGlzLmNocm9tZWRyaXZlciwgYXJncyk7XG4gICAgICBwcm9jZXNzSXNBbGl2ZSA9IHRydWU7XG5cbiAgICAgIC8vIGhhbmRsZSBsb2cgb3V0cHV0XG4gICAgICB0aGlzLnByb2Mub24oJ291dHB1dCcsIChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgICAvLyBpZiB0aGUgY2Qgb3V0cHV0IGlzIG5vdCBwcmludGVkLCBmaW5kIHRoZSBjaHJvbWUgdmVyc2lvbiBhbmQgcHJpbnRcbiAgICAgICAgLy8gd2lsbCBnZXQgYSByZXNwb25zZSBsaWtlXG4gICAgICAgIC8vICAgRGV2VG9vbHMgcmVzcG9uc2U6IHtcbiAgICAgICAgLy8gICAgICBcIkFuZHJvaWQtUGFja2FnZVwiOiBcImlvLmFwcGl1bS5zYW1wbGVhcHBcIixcbiAgICAgICAgLy8gICAgICBcIkJyb3dzZXJcIjogXCJDaHJvbWUvNTUuMC4yODgzLjkxXCIsXG4gICAgICAgIC8vICAgICAgXCJQcm90b2NvbC1WZXJzaW9uXCI6IFwiMS4yXCIsXG4gICAgICAgIC8vICAgICAgXCJVc2VyLUFnZW50XCI6IFwiLi4uXCIsXG4gICAgICAgIC8vICAgICAgXCJXZWJLaXQtVmVyc2lvblwiOiBcIjUzNy4zNlwiXG4gICAgICAgIC8vICAgfVxuICAgICAgICBjb25zdCBvdXQgPSBzdGRvdXQgKyBzdGRlcnI7XG4gICAgICAgIGxldCBtYXRjaCA9IC9cIkJyb3dzZXJcIjogXCIoLiopXCIvLmV4ZWMob3V0KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgd2Vidmlld1ZlcnNpb24gPSBtYXRjaFsxXTtcbiAgICAgICAgICBsb2cuZGVidWcoYFdlYnZpZXcgdmVyc2lvbjogJyR7d2Vidmlld1ZlcnNpb259J2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWxzbyBwcmludCBjaHJvbWVkcml2ZXIgdmVyc2lvbiB0byBsb2dzXG4gICAgICAgIC8vIHdpbGwgb3V0cHV0IHNvbWV0aGluZyBsaWtlXG4gICAgICAgIC8vICBTdGFydGluZyBDaHJvbWVEcml2ZXIgMi4zMy41MDYxMDYgKDhhMDZjMzljNDU4MmZiZmJhYjY5NjZkYmIxYzM4YTkxNzNiZmIxYTIpIG9uIHBvcnQgOTUxNVxuICAgICAgICBtYXRjaCA9IC9TdGFydGluZyBDaHJvbWVEcml2ZXIgKFsuXFxkXSspLy5leGVjKG91dCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGxvZy5kZWJ1ZyhgQ2hyb21lZHJpdmVyIHZlcnNpb246ICcke21hdGNoWzFdfSdgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdpdmUgdGhlIG91dHB1dCBpZiBpdCBpcyByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZSkge1xuICAgICAgICAgIGZvciAobGV0IGxpbmUgb2YgKHN0ZG91dCB8fCAnJykudHJpbSgpLnNwbGl0KCdcXG4nKSkge1xuICAgICAgICAgICAgaWYgKCFsaW5lLnRyaW0oKS5sZW5ndGgpIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGN1cmx5XG4gICAgICAgICAgICBsb2cuZGVidWcoYFtTVERPVVRdICR7bGluZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgbGluZSBvZiAoc3RkZXJyIHx8ICcnKS50cmltKCkuc3BsaXQoJ1xcbicpKSB7XG4gICAgICAgICAgICBpZiAoIWxpbmUudHJpbSgpLmxlbmd0aCkgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY3VybHlcbiAgICAgICAgICAgIGxvZy5lcnJvcihgW1NUREVSUl0gJHtsaW5lfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGhhbmRsZSBvdXQtb2YtYm91bmQgZXhpdCBieSBzaW1wbHkgZW1pdHRpbmcgYSBzdG9wcGVkIHN0YXRlXG4gICAgICB0aGlzLnByb2Mub24oJ2V4aXQnLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgIHByb2Nlc3NJc0FsaXZlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBDaHJvbWVkcml2ZXIuU1RBVEVfU1RPUFBFRCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQSU5HICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlICE9PSBDaHJvbWVkcml2ZXIuU1RBVEVfUkVTVEFSVElORykge1xuICAgICAgICAgIGxldCBtc2cgPSBgQ2hyb21lZHJpdmVyIGV4aXRlZCB1bmV4cGVjdGVkbHkgd2l0aCBjb2RlICR7Y29kZX0sIGAgK1xuICAgICAgICAgICAgICAgICAgICBgc2lnbmFsICR7c2lnbmFsfWA7XG4gICAgICAgICAgbG9nLmVycm9yKG1zZyk7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShDaHJvbWVkcml2ZXIuU1RBVEVfU1RPUFBFRCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbG9nLmluZm8oYFNwYXduaW5nIGNocm9tZWRyaXZlciB3aXRoOiAke3RoaXMuY2hyb21lZHJpdmVyfSBgICtcbiAgICAgICAgICAgICAgIGAke2FyZ3Muam9pbignICcpfWApO1xuICAgICAgLy8gc3RhcnQgc3VicHJvYyBhbmQgd2FpdCBmb3Igc3RhcnREZXRlY3RvclxuICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0YXJ0KHN0YXJ0RGV0ZWN0b3IpO1xuICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yT25saW5lKCk7XG4gICAgICBhd2FpdCB0aGlzLnN0YXJ0U2Vzc2lvbigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZW1pdChDaHJvbWVkcml2ZXIuRVZFTlRfRVJST1IsIGUpO1xuICAgICAgLy8ganVzdCBiZWNhdXNlIHdlIGhhZCBhbiBlcnJvciBkb2Vzbid0IG1lYW4gdGhlIGNocm9tZWRyaXZlciBwcm9jZXNzXG4gICAgICAvLyBmaW5pc2hlZDsgd2Ugc2hvdWxkIGNsZWFuIHVwIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHByb2Nlc3NJc0FsaXZlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvYy5zdG9wKCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICAvLyBvZnRlbiB0aGUgdXNlcidzIENocm9tZSB2ZXJzaW9uIGlzIHRvbyBsb3cgZm9yIHRoZSB2ZXJzaW9uIG9mIENocm9tZWRyaXZlclxuICAgICAgaWYgKGUubWVzc2FnZS5pbmNsdWRlcygnQ2hyb21lIHZlcnNpb24gbXVzdCBiZScpKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gJ1VuYWJsZSB0byBhdXRvbWF0ZSBDaHJvbWUgdmVyc2lvbiBiZWNhdXNlIGl0IGlzIHRvbyBvbGQgZm9yIHRoaXMgdmVyc2lvbiBvZiBDaHJvbWVkcml2ZXIuXFxuJztcbiAgICAgICAgaWYgKHdlYnZpZXdWZXJzaW9uKSB7XG4gICAgICAgICAgbWVzc2FnZSArPSBgQ2hyb21lIHZlcnNpb24gb24gdGhlIGRldmljZTogJHt3ZWJ2aWV3VmVyc2lvbn1cXG5gO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UgKz0gYFZpc2l0ICcke0NIUk9NRURSSVZFUl9UVVRPUklBTH0nIHRvIHRyb3VibGVzaG9vdCB0aGUgcHJvYmxlbS5cXG5gO1xuICAgICAgfVxuXG4gICAgICBtZXNzYWdlICs9IGUubWVzc2FnZTtcbiAgICAgIGxvZy5lcnJvckFuZFRocm93KG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHNlc3Npb25JZCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IENocm9tZWRyaXZlci5TVEFURV9PTkxJTkUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmp3cHJveHkuc2Vzc2lvbklkO1xuICB9XG5cbiAgYXN5bmMgcmVzdGFydCAoKSB7XG4gICAgbG9nLmluZm8oJ1Jlc3RhcnRpbmcgY2hyb21lZHJpdmVyJyk7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IENocm9tZWRyaXZlci5TVEFURV9PTkxJTkUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHJlc3RhcnQgd2hlbiB3ZSdyZSBub3Qgb25saW5lXCIpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZVN0YXRlKENocm9tZWRyaXZlci5TVEFURV9SRVNUQVJUSU5HKTtcbiAgICBhd2FpdCB0aGlzLnN0b3AoZmFsc2UpO1xuICAgIGF3YWl0IHRoaXMuc3RhcnQodGhpcy5jYXBhYmlsaXRpZXMsIGZhbHNlKTtcbiAgfVxuXG4gIGFzeW5jIHdhaXRGb3JPbmxpbmUgKCkge1xuICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgQ0QgaGFzbid0IGNyYXNoZWRcbiAgICBsZXQgY2hyb21lZHJpdmVyU3RvcHBlZCA9IGZhbHNlO1xuICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwoMjAsIDIwMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENocm9tZWRyaXZlci5TVEFURV9TVE9QUEVEKSB7XG4gICAgICAgIC8vIHdlIGFyZSBlaXRoZXIgc3RvcHBlZCBvciBzdG9wcGluZywgc28gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgICAgY2hyb21lZHJpdmVyU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuZ2V0U3RhdHVzKCk7XG4gICAgfSk7XG4gICAgaWYgKGNocm9tZWRyaXZlclN0b3BwZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2hyb21lRHJpdmVyIGNyYXNoZWQgZHVyaW5nIHN0YXJ0dXAuJyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0U3RhdHVzICgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5qd3Byb3h5LmNvbW1hbmQoJy9zdGF0dXMnLCAnR0VUJyk7XG4gIH1cblxuICBhc3luYyBzdGFydFNlc3Npb24gKCkge1xuICAgIC8vIHJldHJ5IHNlc3Npb24gc3RhcnQgNCB0aW1lcywgc29tZXRpbWVzIHRoaXMgZmFpbHMgZHVlIHRvIGFkYlxuICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwoNCwgMjAwLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCgnL3Nlc3Npb24nLCAnUE9TVCcsIHtkZXNpcmVkQ2FwYWJpbGl0aWVzOiB0aGlzLmNhcGFiaWxpdGllc30pO1xuICAgICAgICAvLyBDaHJvbWVEcml2ZXIgY2FuIHJldHVybiBhIHBvc2l0aXZlIHN0YXR1cyBkZXNwaXRlIGZhaWxpbmdcbiAgICAgICAgaWYgKHJlcy5zdGF0dXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzLnZhbHVlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLmVycm9yQW5kVGhyb3coYEZhaWxlZCB0byBzdGFydCBDaHJvbWVkcml2ZXIgc2Vzc2lvbjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmNoYW5nZVN0YXRlKENocm9tZWRyaXZlci5TVEFURV9PTkxJTkUpO1xuICB9XG5cbiAgYXN5bmMgc3RvcCAoZW1pdFN0YXRlcyA9IHRydWUpIHtcbiAgICBpZiAoZW1pdFN0YXRlcykge1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShDaHJvbWVkcml2ZXIuU1RBVEVfU1RPUFBJTkcpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5qd3Byb3h5LmNvbW1hbmQoJycsICdERUxFVEUnKTtcbiAgICAgIGF3YWl0IHRoaXMucHJvYy5zdG9wKCdTSUdURVJNJywgMjAwMDApO1xuICAgICAgaWYgKGVtaXRTdGF0ZXMpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShDaHJvbWVkcml2ZXIuU1RBVEVfU1RPUFBFRCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIGNoYW5nZVN0YXRlIChzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICBsb2cuZGVidWcoYENoYW5nZWQgc3RhdGUgdG8gJyR7c3RhdGV9J2ApO1xuICAgIHRoaXMuZW1pdChDaHJvbWVkcml2ZXIuRVZFTlRfQ0hBTkdFRCwge3N0YXRlfSk7XG4gIH1cblxuICBhc3luYyBzZW5kQ29tbWFuZCAodXJsLCBtZXRob2QsIGJvZHkpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5qd3Byb3h5LmNvbW1hbmQodXJsLCBtZXRob2QsIGJvZHkpO1xuICB9XG5cbiAgYXN5bmMgcHJveHlSZXEgKHJlcSwgcmVzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuandwcm94eS5wcm94eVJlcVJlcyhyZXEsIHJlcyk7XG4gIH1cblxuICBhc3luYyBraWxsQWxsICgpIHtcbiAgICBsZXQgY21kID0gc3lzdGVtLmlzV2luZG93cygpXG4gICAgICA/IGB3bWljIHByb2Nlc3Mgd2hlcmUgXCJjb21tYW5kbGluZSBsaWtlICclY2hyb21lZHJpdmVyLmV4ZSUtLXBvcnQ9JHt0aGlzLnByb3h5UG9ydH0lJ1wiIGRlbGV0ZWBcbiAgICAgIDogYHBraWxsIC0xNSAtZiBcIiR7dGhpcy5jaHJvbWVkcml2ZXJ9LiotLXBvcnQ9JHt0aGlzLnByb3h5UG9ydH1cImA7XG4gICAgbG9nLmRlYnVnKGBLaWxsaW5nIGFueSBvbGQgY2hyb21lZHJpdmVycywgcnVubmluZzogJHtjbWR9YCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IChCLnByb21pc2lmeShjcC5leGVjKSkoY21kKTtcbiAgICAgIGxvZy5kZWJ1ZygnU3VjY2Vzc2Z1bGx5IGNsZWFuZWQgdXAgb2xkIGNocm9tZWRyaXZlcnMnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKCdObyBvbGQgY2hyb21lZHJpdmVycyBzZWVtIHRvIGV4aXN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWRiKSB7XG4gICAgICBsb2cuZGVidWcoYENsZWFuaW5nIGFueSBvbGQgYWRiIGZvcndhcmRlZCBwb3J0IHNvY2tldCBjb25uZWN0aW9uc2ApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChsZXQgY29ubiBvZiBhd2FpdCB0aGlzLmFkYi5nZXRGb3J3YXJkTGlzdCgpKSB7XG4gICAgICAgICAgLy8gY2hyb21lZHJpdmVyIHdpbGwgYXNrIEFEQiB0byBmb3J3YXJkIGEgcG9ydCBsaWtlIFwiZGV2aWNlSWQgdGNwOnBvcnQgbG9jYWxhYnN0cmFjdDp3ZWJ2aWV3X2RldnRvb2xzX3JlbW90ZV9wb3J0XCJcbiAgICAgICAgICBpZiAoY29ubi5pbmRleE9mKCd3ZWJ2aWV3X2RldnRvb2xzJykgIT09IC0xKSB7XG4gICAgICAgICAgICBsZXQgcGFyYW1zID0gY29ubi5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuYWRiLnJlbW92ZVBvcnRGb3J3YXJkKHBhcmFtc1sxXS5yZXBsYWNlKC9bXFxEXSovLCAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy53YXJuKGBVbmFibGUgdG8gY2xlYW4gZm9yd2FyZGVkIHBvcnRzLiBFcnJvcjogJyR7ZXJyLm1lc3NhZ2V9Jy4gQ29udGludWluZy5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBoYXNXb3JraW5nV2VidmlldyAoKSB7XG4gICAgLy8gc29tZXRpbWVzIGNocm9tZWRyaXZlciBzdG9wcyBhdXRvbWF0aW5nIHdlYnZpZXdzLiB0aGlzIG1ldGhvZCBydW5zIGFcbiAgICAvLyBzaW1wbGUgY29tbWFuZCB0byBkZXRlcm1pbmUgb3VyIHN0YXRlLCBhbmQgcmVzcG9uZHMgYWNjb3JkaW5nbHlcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5qd3Byb3h5LmNvbW1hbmQoJy91cmwnLCAnR0VUJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbkNocm9tZWRyaXZlci5FVkVOVF9FUlJPUiA9ICdjaHJvbWVkcml2ZXJfZXJyb3InO1xuQ2hyb21lZHJpdmVyLkVWRU5UX0NIQU5HRUQgPSAnc3RhdGVDaGFuZ2VkJztcbkNocm9tZWRyaXZlci5TVEFURV9TVE9QUEVEID0gJ3N0b3BwZWQnO1xuQ2hyb21lZHJpdmVyLlNUQVRFX1NUQVJUSU5HID0gJ3N0YXJ0aW5nJztcbkNocm9tZWRyaXZlci5TVEFURV9PTkxJTkUgPSAnb25saW5lJztcbkNocm9tZWRyaXZlci5TVEFURV9TVE9QUElORyA9ICdzdG9wcGluZyc7XG5DaHJvbWVkcml2ZXIuU1RBVEVfUkVTVEFSVElORyA9ICdyZXN0YXJ0aW5nJztcblxuZXhwb3J0IHtcbiAgQ2hyb21lZHJpdmVyLCBDSFJPTUVEUklWRVJfQ0hST01FX01BUFBJTkcsIGdldE1vc3RSZWNlbnRDaHJvbWVkcml2ZXIsIENEX1ZFUixcbn07XG5leHBvcnQgZGVmYXVsdCBDaHJvbWVkcml2ZXI7XG4iXSwiZmlsZSI6ImxpYi9jaHJvbWVkcml2ZXIuanMiLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
